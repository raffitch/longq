import hashlib, os
from secrets import token_hex
from fastapi import FastAPI, UploadFile, File, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from sqlmodel import select
from db import init_db, get_session
from models import SessionRow, FileRow, ParsedRow
from schemas import SessionCreate, SessionOut, PublishRequest, BannerOut, FileOut, ParsedOut
from storage import save_upload, session_dir
from parser_adapter import parse_file

app = FastAPI(title="LongevityQ Backend")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)

@app.on_event("startup")
def on_startup():
    os.makedirs("./data", exist_ok=True)
    init_db()

def short_code() -> str:
    return token_hex(3).upper()  # 6 hex chars

# 1) Create session
@app.post("/sessions", response_model=SessionOut)
def create_session(payload: SessionCreate, db=Depends(get_session)):
    s = SessionRow(client_name=payload.client_name, code=short_code())
    db.add(s); db.commit(); db.refresh(s)
    return SessionOut(id=s.id, code=s.code, client_name=s.client_name, state=s.state, published=s.published)

# 2) Banner message (Welcome/Hi, Client...)
@app.get("/sessions/{session_id}/banner", response_model=BannerOut)
def banner(session_id: int, db=Depends(get_session)):
    s = db.get(SessionRow, session_id)
    if not s: raise HTTPException(404, "Session not found")
    if s.client_name and s.state != "CREATED":
        return BannerOut(message=f"Hi, {s.client_name}, your wellness journey is about to begin.")
    return BannerOut(message="Welcome to LongevityQ.")

# 3) Upload PDF (start with 'food' kind)
@app.post("/sessions/{session_id}/upload/{kind}", response_model=FileOut)
def upload_pdf(session_id: int, kind: str, file: UploadFile = File(...), db=Depends(get_session)):
    s = db.get(SessionRow, session_id)
    if not s: raise HTTPException(404, "Session not found")
    s.state = "INGESTING"
    db.add(s)

    path = save_upload(session_id, kind, file.filename, file.file)
    h = hashlib.sha256()
    with open(path, "rb") as f: h.update(f.read())
    filehash = h.hexdigest()

    fr = FileRow(session_id=session_id, kind=kind, filename=file.filename,
                 filehash=filehash, size=os.path.getsize(path), status="uploaded")
    db.add(fr); db.commit(); db.refresh(fr)
    return FileOut(id=fr.id, kind=fr.kind, filename=fr.filename, status=fr.status, error=fr.error)

# 4) Parse uploaded file
@app.post("/files/{file_id}/parse", response_model=ParsedOut)
def parse_uploaded(file_id: int, db=Depends(get_session)):
    fr = db.get(FileRow, file_id)
    if not fr: raise HTTPException(404, "File not found")

    s = db.get(SessionRow, fr.session_id)
    if not s: raise HTTPException(404, "Session not found")

    s.state = "PARSING"; fr.status = "validating"; db.add(s); db.add(fr); db.commit()

    pdf_path = session_dir(fr.session_id) / f"{fr.kind}.pdf"
    if not pdf_path.exists():
        raise HTTPException(400, "PDF not found on disk")

    try:
        version, data = parse_file(fr.kind, pdf_path)
        fr.status = "parsed"; fr.parser_version = version
        db.add(fr)
        existing = db.exec(select(ParsedRow).where(
            (ParsedRow.session_id == fr.session_id) & (ParsedRow.kind == fr.kind)
        )).first()
        if existing:
            existing.data = data
            db.add(existing)
        else:
            db.add(ParsedRow(session_id=fr.session_id, kind=fr.kind, data=data))
        s.state = "READY"; db.add(s)
        db.commit()
        return ParsedOut(session_id=fr.session_id, kind=fr.kind, data=data)
    except Exception as e:
        fr.status = "error"; fr.error = str(e); db.add(fr)
        s.state = "VALIDATING"; db.add(s)
        db.commit()
        raise HTTPException(500, f"Parse failed: {e}")

# 5) Publish toggle
@app.post("/sessions/{session_id}/publish")
def publish(session_id: int, req: PublishRequest, db=Depends(get_session)):
    s = db.get(SessionRow, session_id)
    if not s: raise HTTPException(404, "Session not found")
    s.published = bool(req.publish)
    if s.published: s.state = "PUBLISHED"
    db.add(s); db.commit()
    return {"ok": True, "published": s.published}

# 6) Get parsed data (for front-end)
@app.get("/sessions/{session_id}/parsed/{kind}", response_model=ParsedOut)
def get_parsed(session_id: int, kind: str, db=Depends(get_session)):
    from models import ParsedRow
    pr = db.exec(select(ParsedRow).where(
        (ParsedRow.session_id == session_id) & (ParsedRow.kind == kind)
    )).first()
    if not pr: raise HTTPException(404, "Parsed data not found")
    return ParsedOut(session_id=pr.session_id, kind=pr.kind, data=pr.data)

# 7) Get session (status)
@app.get("/sessions/{session_id}", response_model=SessionOut)
def get_session(session_id: int, db=Depends(get_session)):
    s = db.get(SessionRow, session_id)
    if not s: raise HTTPException(404, "Session not found")
    return SessionOut(id=s.id, code=s.code, client_name=s.client_name, state=s.state, published=s.published)
