# models.py
from __future__ import annotations
from typing import Optional, Any, Dict
from datetime import datetime
from enum import Enum
from sqlmodel import SQLModel, Field
from sqlalchemy import Column, JSON  # <-- use Column + JSON

class SessionState(str, Enum):
    CREATED = "CREATED"
    INGESTING = "INGESTING"
    VALIDATING = "VALIDATING"
    PARSING = "PARSING"
    READY = "READY"
    PUBLISHED = "PUBLISHED"
    CLOSED = "CLOSED"

class SessionRow(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    code: str = Field(index=True)
    client_name: str = Field(index=True)
    state: SessionState = Field(default=SessionState.CREATED)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    published: bool = Field(default=False)

class FileRow(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    session_id: int = Field(index=True, foreign_key="sessionrow.id")
    kind: str = Field(index=True)               # e.g., "food"
    filename: str
    filehash: Optional[str] = None
    size: int
    uploaded_at: datetime = Field(default_factory=datetime.utcnow)
    status: str = Field(default="uploaded")     # uploaded|validating|parsed|error
    error: Optional[str] = None
    parser_version: Optional[str] = None

class ParsedRow(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    session_id: int = Field(index=True, foreign_key="sessionrow.id")
    kind: str = Field(index=True)               # "food"
    # IMPORTANT: type is dict for Pydantic; SQL side uses JSON column:
    data: Dict[str, Any] = Field(sa_column=Column(JSON))
    parsed_at: datetime = Field(default_factory=datetime.utcnow)
