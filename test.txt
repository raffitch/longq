UP017 [*] Use `datetime.UTC` alias
   --> backend/app.py:120:68
    |
118 |             message = str(record.msg)
119 |         entry = {
120 |             "timestamp": datetime.fromtimestamp(record.created, tz=timezone.utc).isoformat(),
    |                                                                    ^^^^^^^^^^^^
121 |             "level": record.levelname,
122 |             "logger": record.name,
    |
help: Convert to `datetime.UTC` alias

UP017 [*] Use `datetime.UTC` alias
   --> backend/app.py:145:68
    |
143 |             message = str(record.msg)
144 |         payload = {
145 |             "timestamp": datetime.fromtimestamp(record.created, tz=timezone.utc).isoformat(),
    |                                                                    ^^^^^^^^^^^^
146 |             "level": record.levelname,
147 |             "logger": record.name,
    |
help: Convert to `datetime.UTC` alias

ANN201 Missing return type annotation for public function `lifespan`
   --> backend/app.py:265:11
    |
264 | @asynccontextmanager
265 | async def lifespan(_: FastAPI):
    |           ^^^^^^^^
266 |     global _event_loop
267 |     _event_loop = asyncio.get_running_loop()
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `_auth_middleware`
   --> backend/app.py:297:11
    |
296 | @app.middleware("http")
297 | async def _auth_middleware(request: Request, call_next):
    |           ^^^^^^^^^^^^^^^^
298 |     if request.url.path in _PUBLIC_HTTP_PATHS:
299 |         return await call_next(request)
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `call_next`
   --> backend/app.py:297:46
    |
296 | @app.middleware("http")
297 | async def _auth_middleware(request: Request, call_next):
    |                                              ^^^^^^^^^
298 |     if request.url.path in _PUBLIC_HTTP_PATHS:
299 |         return await call_next(request)
    |

ANN201 Missing return type annotation for public function `healthz`
   --> backend/app.py:307:11
    |
306 | @app.get("/healthz")
307 | async def healthz():
    |           ^^^^^^^
308 |     return {"status": "ok"}
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `metrics`
   --> backend/app.py:312:5
    |
311 | @app.get("/metrics")
312 | def metrics():
    |     ^^^^^^^
313 |     return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `diagnostics`
   --> backend/app.py:328:5
    |
327 | @app.get("/diagnostics")
328 | def diagnostics(limit: int = 20):
    |     ^^^^^^^^^^^
329 |     limit = max(1, min(limit, DIAGNOSTICS_MAX_ENTRIES))
330 |     return {"entries": _recent_diagnostics(limit)}
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `callback`
   --> backend/app.py:431:18
    |
431 | def _run_in_loop(callback, *args) -> None:
    |                  ^^^^^^^^
432 |     global _event_loop
433 |     try:
    |

ANN002 Missing type annotation for `*args`
   --> backend/app.py:431:28
    |
431 | def _run_in_loop(callback, *args) -> None:
    |                            ^^^^^
432 |     global _event_loop
433 |     try:
    |

ANN202 Missing return type annotation for private function `_cancel`
   --> backend/app.py:448:9
    |
447 | def _cancel_shutdown_timer(reason: str) -> None:
448 |     def _cancel():
    |         ^^^^^^^
449 |         global _shutdown_task
450 |         task = _shutdown_task
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `ws_guest`
   --> backend/app.py:568:11
    |
567 | @app.websocket("/ws/guest")
568 | async def ws_guest(ws: WebSocket):
    |           ^^^^^^^^
569 |     if not await ensure_websocket_authorized(ws):
570 |         return
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `ws_operator`
   --> backend/app.py:590:11
    |
589 | @app.websocket("/ws/operator")
590 | async def ws_operator(ws: WebSocket):
    |           ^^^^^^^^^^^
591 |     if not await ensure_websocket_authorized(ws):
592 |         return
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `broadcast`
   --> backend/app.py:611:11
    |
611 | async def broadcast(event: dict):
    |           ^^^^^^^^^
612 |     """Send JSON event to all connected guest screens."""
613 |     dead = []
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `operator_window_open`
   --> backend/app.py:629:11
    |
627 | # ----------------- Operator window lifecycle -----------------
628 | @app.post("/operator/window-open")
629 | async def operator_window_open():
    |           ^^^^^^^^^^^^^^^^^^^^
630 |     global operator_window_count
631 |     with _operator_window_lock:
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `operator_window_closed`
   --> backend/app.py:640:11
    |
639 | @app.post("/operator/window-closed")
640 | async def operator_window_closed():
    |           ^^^^^^^^^^^^^^^^^^^^^^
641 |     global operator_window_count
642 |     with _operator_window_lock:
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `create_session`
   --> backend/app.py:657:5
    |
655 | # ----------------- Sessions -----------------
656 | @app.post("/sessions", response_model=SessionOut)
657 | def create_session(payload: SessionCreate, db=Depends(get_session)):
    |     ^^^^^^^^^^^^^^
658 |     first = _canonicalize_name_part(payload.first_name)
659 |     last = _canonicalize_name_part(payload.last_name)
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:657:44
    |
655 | # ----------------- Sessions -----------------
656 | @app.post("/sessions", response_model=SessionOut)
657 | def create_session(payload: SessionCreate, db=Depends(get_session)):
    |                                            ^^
658 |     first = _canonicalize_name_part(payload.first_name)
659 |     last = _canonicalize_name_part(payload.last_name)
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:657:47
    |
655 | # ----------------- Sessions -----------------
656 | @app.post("/sessions", response_model=SessionOut)
657 | def create_session(payload: SessionCreate, db=Depends(get_session)):
    |                                               ^^^^^^^^^^^^^^^^^^^^
658 |     first = _canonicalize_name_part(payload.first_name)
659 |     last = _canonicalize_name_part(payload.last_name)
    |

ANN201 Missing return type annotation for public function `list_sessions`
   --> backend/app.py:693:5
    |
692 | @app.get("/sessions", response_model=list[SessionOut])
693 | def list_sessions(db=Depends(get_session)):
    |     ^^^^^^^^^^^^^
694 |     rows = db.exec(select(SessionRow).order_by(SessionRow.id.desc())).all()
695 |     return [
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:693:19
    |
692 | @app.get("/sessions", response_model=list[SessionOut])
693 | def list_sessions(db=Depends(get_session)):
    |                   ^^
694 |     rows = db.exec(select(SessionRow).order_by(SessionRow.id.desc())).all()
695 |     return [
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:693:22
    |
692 | @app.get("/sessions", response_model=list[SessionOut])
693 | def list_sessions(db=Depends(get_session)):
    |                      ^^^^^^^^^^^^^^^^^^^^
694 |     rows = db.exec(select(SessionRow).order_by(SessionRow.id.desc())).all()
695 |     return [
    |

ANN201 Missing return type annotation for public function `get_session_status`
   --> backend/app.py:712:5
    |
711 | @app.get("/sessions/{session_id}", response_model=SessionOut)
712 | def get_session_status(session_id: int, db=Depends(get_session)):
    |     ^^^^^^^^^^^^^^^^^^
713 |     s = db.get(SessionRow, session_id)
714 |     if not s:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:712:41
    |
711 | @app.get("/sessions/{session_id}", response_model=SessionOut)
712 | def get_session_status(session_id: int, db=Depends(get_session)):
    |                                         ^^
713 |     s = db.get(SessionRow, session_id)
714 |     if not s:
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:712:44
    |
711 | @app.get("/sessions/{session_id}", response_model=SessionOut)
712 | def get_session_status(session_id: int, db=Depends(get_session)):
    |                                            ^^^^^^^^^^^^^^^^^^^^
713 |     s = db.get(SessionRow, session_id)
714 |     if not s:
    |

ANN201 Missing return type annotation for public function `update_session`
   --> backend/app.py:730:5
    |
729 | @app.patch("/sessions/{session_id}", response_model=SessionOut)
730 | def update_session(session_id: int, payload: SessionUpdate, db=Depends(get_session)):
    |     ^^^^^^^^^^^^^^
731 |     s = db.get(SessionRow, session_id)
732 |     if not s:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:730:61
    |
729 | @app.patch("/sessions/{session_id}", response_model=SessionOut)
730 | def update_session(session_id: int, payload: SessionUpdate, db=Depends(get_session)):
    |                                                             ^^
731 |     s = db.get(SessionRow, session_id)
732 |     if not s:
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:730:64
    |
729 | @app.patch("/sessions/{session_id}", response_model=SessionOut)
730 | def update_session(session_id: int, payload: SessionUpdate, db=Depends(get_session)):
    |                                                                ^^^^^^^^^^^^^^^^^^^^
731 |     s = db.get(SessionRow, session_id)
732 |     if not s:
    |

ANN201 Missing return type annotation for public function `banner`
   --> backend/app.py:789:5
    |
787 | # Greet immediately
788 | @app.get("/sessions/{session_id}/banner", response_model=BannerOut)
789 | def banner(session_id: int, db=Depends(get_session)):
    |     ^^^^^^
790 |     s = db.get(SessionRow, session_id)
791 |     if not s:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:789:29
    |
787 | # Greet immediately
788 | @app.get("/sessions/{session_id}/banner", response_model=BannerOut)
789 | def banner(session_id: int, db=Depends(get_session)):
    |                             ^^
790 |     s = db.get(SessionRow, session_id)
791 |     if not s:
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:789:32
    |
787 | # Greet immediately
788 | @app.get("/sessions/{session_id}/banner", response_model=BannerOut)
789 | def banner(session_id: int, db=Depends(get_session)):
    |                                ^^^^^^^^^^^^^^^^^^^^
790 |     s = db.get(SessionRow, session_id)
791 |     if not s:
    |

ANN201 Missing return type annotation for public function `upload_report`
   --> backend/app.py:799:5
    |
797 | # ----------------- Upload / Parse / Publish -----------------
798 | @app.post("/sessions/{session_id}/upload/{kind}", response_model=FileOut)
799 | def upload_report(
    |     ^^^^^^^^^^^^^
800 |     session_id: int,
801 |     kind: str,
    |
help: Add return type annotation

B008 Do not perform function call `File` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:802:24
    |
800 |     session_id: int,
801 |     kind: str,
802 |     file: UploadFile = File(...),
    |                        ^^^^^^^^^
803 |     db=Depends(get_session),
804 | ):
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:803:5
    |
801 |     kind: str,
802 |     file: UploadFile = File(...),
803 |     db=Depends(get_session),
    |     ^^
804 | ):
805 |     s = db.get(SessionRow, session_id)
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:803:8
    |
801 |     kind: str,
802 |     file: UploadFile = File(...),
803 |     db=Depends(get_session),
    |        ^^^^^^^^^^^^^^^^^^^^
804 | ):
805 |     s = db.get(SessionRow, session_id)
    |

ANN201 Missing return type annotation for public function `parse_uploaded`
   --> backend/app.py:882:5
    |
881 | @app.post("/files/{file_id}/parse", response_model=ParsedOut)
882 | def parse_uploaded(file_id: int, db=Depends(get_session)):
    |     ^^^^^^^^^^^^^^
883 |     fr = db.get(FileRow, file_id)
884 |     if not fr:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:882:34
    |
881 | @app.post("/files/{file_id}/parse", response_model=ParsedOut)
882 | def parse_uploaded(file_id: int, db=Depends(get_session)):
    |                                  ^^
883 |     fr = db.get(FileRow, file_id)
884 |     if not fr:
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:882:37
    |
881 | @app.post("/files/{file_id}/parse", response_model=ParsedOut)
882 | def parse_uploaded(file_id: int, db=Depends(get_session)):
    |                                     ^^^^^^^^^^^^^^^^^^^^
883 |     fr = db.get(FileRow, file_id)
884 |     if not fr:
    |

ANN201 Missing return type annotation for public function `publish`
   --> backend/app.py:971:11
    |
970 | @app.post("/sessions/{session_id}/publish")
971 | async def publish(session_id: int, req: PublishRequest, db=Depends(get_session)):
    |           ^^^^^^^
972 |     s = db.get(SessionRow, session_id)
973 |     if not s:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:971:57
    |
970 | @app.post("/sessions/{session_id}/publish")
971 | async def publish(session_id: int, req: PublishRequest, db=Depends(get_session)):
    |                                                         ^^
972 |     s = db.get(SessionRow, session_id)
973 |     if not s:
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:971:60
    |
970 | @app.post("/sessions/{session_id}/publish")
971 | async def publish(session_id: int, req: PublishRequest, db=Depends(get_session)):
    |                                                            ^^^^^^^^^^^^^^^^^^^^
972 |     s = db.get(SessionRow, session_id)
973 |     if not s:
    |

ANN201 Missing return type annotation for public function `get_parsed`
    --> backend/app.py:1007:5
     |
1005 | # Strict publish gate
1006 | @app.get("/sessions/{session_id}/parsed/{kind}", response_model=ParsedOut)
1007 | def get_parsed(session_id: int, kind: str, db=Depends(get_session)):
     |     ^^^^^^^^^^
1008 |     s = db.get(SessionRow, session_id)
1009 |     if not s:
     |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1007:44
     |
1005 | # Strict publish gate
1006 | @app.get("/sessions/{session_id}/parsed/{kind}", response_model=ParsedOut)
1007 | def get_parsed(session_id: int, kind: str, db=Depends(get_session)):
     |                                            ^^
1008 |     s = db.get(SessionRow, session_id)
1009 |     if not s:
     |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    --> backend/app.py:1007:47
     |
1005 | # Strict publish gate
1006 | @app.get("/sessions/{session_id}/parsed/{kind}", response_model=ParsedOut)
1007 | def get_parsed(session_id: int, kind: str, db=Depends(get_session)):
     |                                               ^^^^^^^^^^^^^^^^^^^^
1008 |     s = db.get(SessionRow, session_id)
1009 |     if not s:
     |

ANN201 Missing return type annotation for public function `get_parsed_bundle`
    --> backend/app.py:1022:5
     |
1021 | @app.get("/sessions/{session_id}/parsed", response_model=ParsedBundleOut)
1022 | def get_parsed_bundle(session_id: int, db=Depends(get_session)):
     |     ^^^^^^^^^^^^^^^^^
1023 |     s = db.get(SessionRow, session_id)
1024 |     if not s:
     |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1022:40
     |
1021 | @app.get("/sessions/{session_id}/parsed", response_model=ParsedBundleOut)
1022 | def get_parsed_bundle(session_id: int, db=Depends(get_session)):
     |                                        ^^
1023 |     s = db.get(SessionRow, session_id)
1024 |     if not s:
     |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    --> backend/app.py:1022:43
     |
1021 | @app.get("/sessions/{session_id}/parsed", response_model=ParsedBundleOut)
1022 | def get_parsed_bundle(session_id: int, db=Depends(get_session)):
     |                                           ^^^^^^^^^^^^^^^^^^^^
1023 |     s = db.get(SessionRow, session_id)
1024 |     if not s:
     |

ANN201 Missing return type annotation for public function `display_current`
    --> backend/app.py:1036:5
     |
1034 | # ----------------- Guest display binding -----------------
1035 | @app.get("/display/current", response_model=DisplayOut)
1036 | def display_current(db=Depends(get_session)):
     |     ^^^^^^^^^^^^^^^
1037 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1038 |     if not d or not d.current_session_id:
     |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1036:21
     |
1034 | # ----------------- Guest display binding -----------------
1035 | @app.get("/display/current", response_model=DisplayOut)
1036 | def display_current(db=Depends(get_session)):
     |                     ^^
1037 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1038 |     if not d or not d.current_session_id:
     |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    --> backend/app.py:1036:24
     |
1034 | # ----------------- Guest display binding -----------------
1035 | @app.get("/display/current", response_model=DisplayOut)
1036 | def display_current(db=Depends(get_session)):
     |                        ^^^^^^^^^^^^^^^^^^^^
1037 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1038 |     if not d or not d.current_session_id:
     |

ANN201 Missing return type annotation for public function `display_set`
    --> backend/app.py:1073:11
     |
1072 | @app.post("/display/current")
1073 | async def display_set(req: DisplaySet, db=Depends(get_session)):
     |           ^^^^^^^^^^^
1074 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1075 |     if not d:
     |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1073:40
     |
1072 | @app.post("/display/current")
1073 | async def display_set(req: DisplaySet, db=Depends(get_session)):
     |                                        ^^
1074 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1075 |     if not d:
     |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    --> backend/app.py:1073:43
     |
1072 | @app.post("/display/current")
1073 | async def display_set(req: DisplaySet, db=Depends(get_session)):
     |                                           ^^^^^^^^^^^^^^^^^^^^
1074 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1075 |     if not d:
     |

ANN201 Missing return type annotation for public function `close_session`
    --> backend/app.py:1106:5
     |
1105 | @app.post("/sessions/{session_id}/close")
1106 | def close_session(session_id: int, db=Depends(get_session)):
     |     ^^^^^^^^^^^^^
1107 |     s = db.get(SessionRow, session_id)
1108 |     if not s:
     |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1106:36
     |
1105 | @app.post("/sessions/{session_id}/close")
1106 | def close_session(session_id: int, db=Depends(get_session)):
     |                                    ^^
1107 |     s = db.get(SessionRow, session_id)
1108 |     if not s:
     |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    --> backend/app.py:1106:39
     |
1105 | @app.post("/sessions/{session_id}/close")
1106 | def close_session(session_id: int, db=Depends(get_session)):
     |                                       ^^^^^^^^^^^^^^^^^^^^
1107 |     s = db.get(SessionRow, session_id)
1108 |     if not s:
     |

I001 [*] Import block is un-sorted or un-formatted
 --> backend/db.py:1:1
  |
1 | / import os
2 | | from sqlmodel import SQLModel, create_engine, Session
3 | | from sqlalchemy.pool import StaticPool
4 | |
5 | | from paths import backend_dir
  | |_____________________________^
6 |
7 |   DB_URL = os.getenv("DB_URL")
  |
help: Organize imports

ANN201 Missing return type annotation for public function `init_db`
  --> backend/db.py:23:5
   |
23 | def init_db():
   |     ^^^^^^^
24 |     if DB_URL:
25 |         SQLModel.metadata.create_all(engine)
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `get_session`
  --> backend/db.py:31:5
   |
31 | def get_session():
   |     ^^^^^^^^^^^
32 |     with Session(engine) as session:
33 |         yield session
   |
help: Add return type annotation

I001 [*] Import block is un-sorted or un-formatted
  --> backend/maintenance.py:11:1
   |
 9 |   """
10 |
11 | / from __future__ import annotations
12 | |
13 | | import argparse
14 | | import json
15 | | import os
16 | | import sys
17 | | import time
18 | | from dataclasses import dataclass
19 | | from pathlib import Path
20 | | from collections.abc import Iterable
21 | |
22 | | from paths import ensure_app_dirs, runtime_dir
23 | | from session_fs import (
24 | |     SESSION_LOCK_NAME,
25 | |     default_session_retention_hours,
26 | |     iter_session_dirs,
27 | |     purge_session_directories,
28 | |     reset_tmp_directory,
29 | |     remove_session_lock,
30 | | )
   | |_^
31 |
32 |   BACKEND_PID_NAME = "backend.pid"
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
 --> backend/models.py:2:1
  |
1 |   # models.py
2 | / from __future__ import annotations
3 | |
4 | | from typing import Any
5 | | from datetime import datetime
6 | | from enum import Enum
7 | | from sqlmodel import SQLModel, Field
8 | | from sqlalchemy import Column, JSON, String  # <-- use Column + JSON
  | |___________________________________________^
  |
help: Organize imports

E402 Module level import not at top of file
  --> backend/models.py:63:1
   |
62 | # --- Fixed guest-screen binding model ---
63 | from sqlmodel import Field as _Field
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

E401 [*] Multiple imports on one line
 --> backend/parse_food_pdf.py:3:1
  |
1 | #!/usr/bin/env python3
2 | # (See docstring in previous attempt for details.)
3 | import argparse, json, math, re, statistics
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
4 | from typing import Any
5 | import fitz  # PyMuPDF
  |
help: Split imports

I001 [*] Import block is un-sorted or un-formatted
 --> backend/parse_food_pdf.py:3:1
  |
1 |   #!/usr/bin/env python3
2 |   # (See docstring in previous attempt for details.)
3 | / import argparse, json, math, re, statistics
4 | | from typing import Any
5 | | import fitz  # PyMuPDF
  | |___________^
6 |
7 |   CATEGORY_NAMES = [
  |
help: Organize imports

ANN201 Missing return type annotation for public function `page_spans`
  --> backend/parse_food_pdf.py:64:5
   |
64 | def page_spans(page: fitz.Page):
   |     ^^^^^^^^^^
65 |     d = page.get_text("dict")
66 |     out = []
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `cluster_lines`
  --> backend/parse_food_pdf.py:81:5
   |
81 | def cluster_lines(spans, y_tol=Y_LINE_TOL):
   |     ^^^^^^^^^^^^^
82 |     lines = []
83 |     for sp in spans:
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `spans`
  --> backend/parse_food_pdf.py:81:19
   |
81 | def cluster_lines(spans, y_tol=Y_LINE_TOL):
   |                   ^^^^^
82 |     lines = []
83 |     for sp in spans:
   |

ANN001 Missing type annotation for function argument `y_tol`
  --> backend/parse_food_pdf.py:81:26
   |
81 | def cluster_lines(spans, y_tol=Y_LINE_TOL):
   |                          ^^^^^
82 |     lines = []
83 |     for sp in spans:
   |

ANN201 Missing return type annotation for public function `find_total_lines`
   --> backend/parse_food_pdf.py:99:5
    |
 99 | def find_total_lines(lines):
    |     ^^^^^^^^^^^^^^^^
100 |     totals = []
101 |     for ln in lines:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:99:22
    |
 99 | def find_total_lines(lines):
    |                      ^^^^^
100 |     totals = []
101 |     for ln in lines:
    |

ANN201 Missing return type annotation for public function `detect_headers`
   --> backend/parse_food_pdf.py:112:5
    |
112 | def detect_headers(lines):
    |     ^^^^^^^^^^^^^^
113 |     allowed = set(CATEGORY_NAMES)
114 |     headers = []
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:112:20
    |
112 | def detect_headers(lines):
    |                    ^^^^^
113 |     allowed = set(CATEGORY_NAMES)
114 |     headers = []
    |

ANN201 Missing return type annotation for public function `group_headers_into_rows`
   --> backend/parse_food_pdf.py:124:5
    |
124 | def group_headers_into_rows(headers):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
125 |     rows = []
126 |     for h in headers:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `headers`
   --> backend/parse_food_pdf.py:124:29
    |
124 | def group_headers_into_rows(headers):
    |                             ^^^^^^^
125 |     rows = []
126 |     for h in headers:
    |

ANN201 Missing return type annotation for public function `build_row_boxes`
   --> backend/parse_food_pdf.py:142:5
    |
142 | def build_row_boxes(rows, page_w: float):
    |     ^^^^^^^^^^^^^^^
143 |     boxes = {}
144 |     for row in rows:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `rows`
   --> backend/parse_food_pdf.py:142:21
    |
142 | def build_row_boxes(rows, page_w: float):
    |                     ^^^^
143 |     boxes = {}
144 |     for row in rows:
    |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:166:24
    |
166 | def find_footer_page_y(lines, page_height: float) -> float:
    |                        ^^^^^
167 |     for ln in reversed(lines):
168 |         txt = " ".join(s["t"] for s in ln).strip().lower()
    |

ANN001 Missing type annotation for function argument `a0`
   --> backend/parse_food_pdf.py:177:17
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                 ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `a1`
   --> backend/parse_food_pdf.py:177:21
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                     ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `b0`
   --> backend/parse_food_pdf.py:177:25
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                         ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `b1`
   --> backend/parse_food_pdf.py:177:29
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                             ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN201 Missing return type annotation for public function `clamp_y1_with_totals`
   --> backend/parse_food_pdf.py:181:5
    |
181 | def clamp_y1_with_totals(cat_boxes, totals):
    |     ^^^^^^^^^^^^^^^^^^^^
182 |     new = {}
183 |     for name, (y0, _, x0, x1) in cat_boxes.items():
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `cat_boxes`
   --> backend/parse_food_pdf.py:181:26
    |
181 | def clamp_y1_with_totals(cat_boxes, totals):
    |                          ^^^^^^^^^
182 |     new = {}
183 |     for name, (y0, _, x0, x1) in cat_boxes.items():
    |

ANN001 Missing type annotation for function argument `totals`
   --> backend/parse_food_pdf.py:181:37
    |
181 | def clamp_y1_with_totals(cat_boxes, totals):
    |                                     ^^^^^^
182 |     new = {}
183 |     for name, (y0, _, x0, x1) in cat_boxes.items():
    |

ANN201 Missing return type annotation for public function `find_scores_in_box`
   --> backend/parse_food_pdf.py:195:5
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |     ^^^^^^^^^^^^^^^^^^
196 |     scores = []
197 |     for ln in lines:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:195:24
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                        ^^^^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x0`
   --> backend/parse_food_pdf.py:195:31
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                               ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x1`
   --> backend/parse_food_pdf.py:195:35
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                                   ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y0`
   --> backend/parse_food_pdf.py:195:39
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                                       ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y1`
   --> backend/parse_food_pdf.py:195:43
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                                           ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN201 Missing return type annotation for public function `cluster_score_rows`
   --> backend/parse_food_pdf.py:211:5
    |
211 | def cluster_score_rows(scores, tol=ROW_CLUSTER_TOL):
    |     ^^^^^^^^^^^^^^^^^^
212 |     rows = []
213 |     for sc in scores:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `scores`
   --> backend/parse_food_pdf.py:211:24
    |
211 | def cluster_score_rows(scores, tol=ROW_CLUSTER_TOL):
    |                        ^^^^^^
212 |     rows = []
213 |     for sc in scores:
    |

ANN001 Missing type annotation for function argument `tol`
   --> backend/parse_food_pdf.py:211:32
    |
211 | def cluster_score_rows(scores, tol=ROW_CLUSTER_TOL):
    |                                ^^^
212 |     rows = []
213 |     for sc in scores:
    |

ANN201 Missing return type annotation for public function `build_row_bands`
   --> backend/parse_food_pdf.py:229:5
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |     ^^^^^^^^^^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `row_centers`
   --> backend/parse_food_pdf.py:229:21
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |                     ^^^^^^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |

ANN001 Missing type annotation for function argument `cat_y0`
   --> backend/parse_food_pdf.py:229:34
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |                                  ^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |

ANN001 Missing type annotation for function argument `cat_y1`
   --> backend/parse_food_pdf.py:229:42
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |                                          ^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |

ANN201 Missing return type annotation for public function `smart_join`
   --> backend/parse_food_pdf.py:242:5
    |
242 | def smart_join(parts):
    |     ^^^^^^^^^^
243 |     if not parts:
244 |         return ""
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `parts`
   --> backend/parse_food_pdf.py:242:16
    |
242 | def smart_join(parts):
    |                ^^^^^
243 |     if not parts:
244 |         return ""
    |

ANN201 Missing return type annotation for public function `collect_label_window`
   --> backend/parse_food_pdf.py:262:5
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |     ^^^^^^^^^^^^^^^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:262:26
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                          ^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y_top`
   --> backend/parse_food_pdf.py:262:33
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                 ^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y_bot`
   --> backend/parse_food_pdf.py:262:40
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                        ^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x_left`
   --> backend/parse_food_pdf.py:262:47
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                               ^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x_right`
   --> backend/parse_food_pdf.py:262:55
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                                       ^^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `expected_set`
   --> backend/parse_food_pdf.py:262:64
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                                                ^^^^^^^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN201 Missing return type annotation for public function `quantiles`
   --> backend/parse_food_pdf.py:280:5
    |
280 | def quantiles(values, qs):
    |     ^^^^^^^^^
281 |     if not values:
282 |         return [0.0] * len(qs)
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `values`
   --> backend/parse_food_pdf.py:280:15
    |
280 | def quantiles(values, qs):
    |               ^^^^^^
281 |     if not values:
282 |         return [0.0] * len(qs)
    |

ANN001 Missing type annotation for function argument `qs`
   --> backend/parse_food_pdf.py:280:23
    |
280 | def quantiles(values, qs):
    |                       ^^
281 |     if not values:
282 |         return [0.0] * len(qs)
    |

ANN201 Missing return type annotation for public function `kmeans1d_median`
   --> backend/parse_food_pdf.py:291:5
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |     ^^^^^^^^^^^^^^^
292 |     if not xs:
293 |         return []
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `xs`
   --> backend/parse_food_pdf.py:291:21
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |                     ^^
292 |     if not xs:
293 |         return []
    |

ANN001 Missing type annotation for function argument `k`
   --> backend/parse_food_pdf.py:291:25
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |                         ^
292 |     if not xs:
293 |         return []
    |

ANN001 Missing type annotation for function argument `iters`
   --> backend/parse_food_pdf.py:291:30
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |                              ^^^^^
292 |     if not xs:
293 |         return []
    |

ANN201 Missing return type annotation for public function `header_has_items`
   --> backend/parse_food_pdf.py:314:5
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |     ^^^^^^^^^^^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |
help: Add return type annotation: `bool`

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:314:22
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                      ^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `header`
   --> backend/parse_food_pdf.py:314:29
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                             ^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `header_row`
   --> backend/parse_food_pdf.py:314:52
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                                                    ^^^^^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `all_headers`
   --> backend/parse_food_pdf.py:314:64
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                                                                ^^^^^^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN201 Missing return type annotation for public function `decide_order_mode`
   --> backend/parse_food_pdf.py:340:5
    |
340 | def decide_order_mode(items_xy, row_groups):
    |     ^^^^^^^^^^^^^^^^^
341 |     if not items_xy:
342 |         return "row"
    |
help: Add return type annotation: `str`

ANN001 Missing type annotation for function argument `items_xy`
   --> backend/parse_food_pdf.py:340:23
    |
340 | def decide_order_mode(items_xy, row_groups):
    |                       ^^^^^^^^
341 |     if not items_xy:
342 |         return "row"
    |

ANN001 Missing type annotation for function argument `row_groups`
   --> backend/parse_food_pdf.py:340:33
    |
340 | def decide_order_mode(items_xy, row_groups):
    |                                 ^^^^^^^^^^
341 |     if not items_xy:
342 |         return "row"
    |

ANN202 Missing return type annotation for private function `col_idx`
   --> backend/parse_food_pdf.py:346:9
    |
344 |     centers = kmeans1d_median(xs, k=4, iters=25)
345 |
346 |     def col_idx(x):
    |         ^^^^^^^
347 |         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `x`
   --> backend/parse_food_pdf.py:346:17
    |
344 |     centers = kmeans1d_median(xs, k=4, iters=25)
345 |
346 |     def col_idx(x):
    |                 ^
347 |         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |

RUF059 Unpacked variable `hy0` is never used
   --> backend/parse_food_pdf.py:425:17
    |
423 |                 cname = h["name"]
424 |                 y0, y1, x0, x1 = cat_boxes[cname]
425 |                 hy0, hy1 = header_y_map.get(cname, (None, None))
    |                 ^^^
426 |
427 |                 scores = find_scores_in_box(lines, x0, x1, y0, y1)
    |
help: Prefix it with an underscore or any other dummy variable pattern

B905 `zip()` without an explicit `strict=` parameter
   --> backend/parse_food_pdf.py:440:48
    |
439 |                 tmp = []
440 |                 for g, (band_top, band_bot) in zip(row_groups, bands):
    |                                                ^^^^^^^^^^^^^^^^^^^^^^
441 |                     g = sorted(g, key=lambda s: s["x"])
442 |                     xs = [sc["x"] for sc in g]
    |
help: Add explicit value for parameter `strict=`

ANN202 Missing return type annotation for private function `col_index`
   --> backend/parse_food_pdf.py:489:25
    |
487 |                     centers = kmeans1d_median(xs_all, k=4, iters=25)
488 |
489 |                     def col_index(x):
    |                         ^^^^^^^^^
490 |                         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `x`
   --> backend/parse_food_pdf.py:489:35
    |
487 |                     centers = kmeans1d_median(xs_all, k=4, iters=25)
488 |
489 |                     def col_index(x):
    |                                   ^
490 |                         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |

B023 Function definition does not bind loop variable `centers`
   --> backend/parse_food_pdf.py:490:46
    |
489 |                     def col_index(x):
490 |                         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |                                              ^^^^^^^
491 |
492 |                     uniq_rows = sorted({round(v, 2) for v in (it["_ry"] for it in tmp)})
    |

B023 Function definition does not bind loop variable `centers`
   --> backend/parse_food_pdf.py:490:79
    |
489 |                     def col_index(x):
490 |                         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |                                                                               ^^^^^^^
491 |
492 |                     uniq_rows = sorted({round(v, 2) for v in (it["_ry"] for it in tmp)})
    |

B023 Function definition does not bind loop variable `i`
   --> backend/parse_food_pdf.py:490:87
    |
489 |                     def col_index(x):
490 |                         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |                                                                                       ^
491 |
492 |                     uniq_rows = sorted({round(v, 2) for v in (it["_ry"] for it in tmp)})
    |

ANN202 Missing return type annotation for private function `row_index`
   --> backend/parse_food_pdf.py:494:25
    |
492 |                     uniq_rows = sorted({round(v, 2) for v in (it["_ry"] for it in tmp)})
493 |
494 |                     def row_index(ry):
    |                         ^^^^^^^^^
495 |                         return min(range(len(uniq_rows)), key=lambda i: abs(ry - uniq_rows[i]))
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `ry`
   --> backend/parse_food_pdf.py:494:35
    |
492 |                     uniq_rows = sorted({round(v, 2) for v in (it["_ry"] for it in tmp)})
493 |
494 |                     def row_index(ry):
    |                                   ^^
495 |                         return min(range(len(uniq_rows)), key=lambda i: abs(ry - uniq_rows[i]))
    |

B023 Function definition does not bind loop variable `uniq_rows`
   --> backend/parse_food_pdf.py:495:46
    |
494 |                     def row_index(ry):
495 |                         return min(range(len(uniq_rows)), key=lambda i: abs(ry - uniq_rows[i]))
    |                                              ^^^^^^^^^
496 |
497 |                     for it in tmp:
    |

B023 Function definition does not bind loop variable `uniq_rows`
   --> backend/parse_food_pdf.py:495:82
    |
494 |                     def row_index(ry):
495 |                         return min(range(len(uniq_rows)), key=lambda i: abs(ry - uniq_rows[i]))
    |                                                                                  ^^^^^^^^^
496 |
497 |                     for it in tmp:
    |

B023 Function definition does not bind loop variable `i`
   --> backend/parse_food_pdf.py:495:92
    |
494 |                     def row_index(ry):
495 |                         return min(range(len(uniq_rows)), key=lambda i: abs(ry - uniq_rows[i]))
    |                                                                                            ^
496 |
497 |                     for it in tmp:
    |

ANN201 Missing return type annotation for public function `main`
   --> backend/parse_food_pdf.py:525:5
    |
525 | def main():
    |     ^^^^
526 |     ap = argparse.ArgumentParser(description="Parse PDF → JSON (v6g: per-category AUTO ordering).")
527 |     ap.add_argument("pdf")
    |
help: Add return type annotation: `None`

I001 [*] Import block is un-sorted or un-formatted
  --> backend/parse_hormones_pdf.py:4:1
   |
 2 |   """Parse Biostar hormones report PDFs into structured data."""
 3 |
 4 | / from __future__ import annotations
 5 | |
 6 | | import re
 7 | | import os
 8 | | from typing import Any
 9 | |
10 | | import fitz  # PyMuPDF
   | |___________^
   |
help: Organize imports

F401 [*] `os` imported but unused
 --> backend/parse_hormones_pdf.py:7:8
  |
6 | import re
7 | import os
  |        ^^
8 | from typing import Any
  |
help: Remove unused import: `os`

RUF001 String contains ambiguous `Β` (GREEK CAPITAL LETTER BETA). Did you mean `B` (LATIN CAPITAL LETTER B)?
  --> backend/parse_hormones_pdf.py:20:41
   |
18 |         return s
19 |     s = re.sub(r"[\u2010\u2011\u2012\u2013\u2014\u2212]", "-", s)
20 |     s = s.replace("β", "Beta").replace("Β", "Beta").replace("\u200b", "")
   |                                         ^
21 |     s = re.sub(r"\s+", " ", s)
22 |     return s.strip()
   |

B007 Loop control variable `idx` not used within loop body
  --> backend/parse_hormones_pdf.py:74:9
   |
72 | ) -> list[list[tuple[str, float]]]:
73 |     blocks: list[list[tuple[str, float]]] = []
74 |     for idx, page in enumerate(doc):
   |         ^^^
75 |         blk = _page_rate_block(page)
76 |         if not blk:
   |
help: Rename unused `idx` to `_idx`

I001 [*] Import block is un-sorted or un-formatted
  --> backend/parse_nutrition_pdf.py:4:1
   |
 2 |   """Parse nutrition report PDFs into structured data."""
 3 |
 4 | / from __future__ import annotations
 5 | |
 6 | | import os
 7 | | import re
 8 | | from collections.abc import Iterable
 9 | | from typing import Any
10 | |
11 | | import fitz  # PyMuPDF
   | |___________^
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> backend/parse_toxins_pdf.py:4:1
   |
 2 |   """Parse Biostar toxins report PDFs into structured data."""
 3 |
 4 | / from __future__ import annotations
 5 | |
 6 | | import os
 7 | | import re
 8 | | from typing import Any
 9 | |
10 | | import fitz  # PyMuPDF
   | |___________^
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
 --> backend/paths.py:1:1
  |
1 | / import os
2 | | from functools import lru_cache
3 | | from pathlib import Path
  | |________________________^
  |
help: Organize imports

E402 Module level import not at top of file
  --> backend/runner.py:12:1
   |
10 |         sys.path.insert(0, candidate)
11 |
12 | from uvicorn import Config, Server
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | try:  # prefer local import when executed from backend directory
   |

I001 [*] Import block is un-sorted or un-formatted
 --> backend/schemas.py:1:1
  |
1 | / from pydantic import BaseModel
2 | | from typing import Any, Literal
  | |_______________________________^
  |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> backend/session_fs.py:1:1
   |
 1 | / from __future__ import annotations
 2 | |
 3 | | import errno
 4 | | import os
 5 | | import shutil
 6 | | import time
 7 | | from dataclasses import dataclass
 8 | | from pathlib import Path
 9 | | from collections.abc import Iterable
10 | |
11 | | from paths import sessions_dir
   | |______________________________^
12 |
13 |   SESSION_LOCK_NAME = "session.lock"
   |
help: Organize imports

ANN001 Missing type annotation for function argument `fileobj`
 --> backend/storage.py:7:45
  |
7 | def save_upload(session_id: int, kind: str, fileobj) -> bytes:
  |                                             ^^^^^^^
8 |     """Store the uploaded PDF bytes in memory and return the raw payload."""
9 |     data = fileobj.read()
  |

ANN201 Missing return type annotation for public function `idle_app`
  --> backend/tests/test_idle_shutdown.py:15:11
   |
14 | @pytest_asyncio.fixture
15 | async def idle_app(monkeypatch):
   |           ^^^^^^^^
16 |     monkeypatch.setenv("EXIT_WHEN_IDLE", "true")
17 |     monkeypatch.setenv("EXIT_IDLE_DEBOUNCE_SEC", "0.05")
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_idle_shutdown.py:15:20
   |
14 | @pytest_asyncio.fixture
15 | async def idle_app(monkeypatch):
   |                    ^^^^^^^^^^^
16 |     monkeypatch.setenv("EXIT_WHEN_IDLE", "true")
17 |     monkeypatch.setenv("EXIT_IDLE_DEBOUNCE_SEC", "0.05")
   |

ANN201 Missing return type annotation for public function `test_idle_shutdown_triggers_after_debounce`
  --> backend/tests/test_idle_shutdown.py:37:11
   |
36 | @pytest.mark.asyncio
37 | async def test_idle_shutdown_triggers_after_debounce(idle_app):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |     idle_app.operator_clients.clear()
39 |     idle_app.guest_clients.clear()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `idle_app`
  --> backend/tests/test_idle_shutdown.py:37:54
   |
36 | @pytest.mark.asyncio
37 | async def test_idle_shutdown_triggers_after_debounce(idle_app):
   |                                                      ^^^^^^^^
38 |     idle_app.operator_clients.clear()
39 |     idle_app.guest_clients.clear()
   |

ANN201 Missing return type annotation for public function `test_idle_shutdown_cancelled_when_client_returns`
  --> backend/tests/test_idle_shutdown.py:48:11
   |
47 | @pytest.mark.asyncio
48 | async def test_idle_shutdown_cancelled_when_client_returns(idle_app):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
49 |     idle_app.operator_clients.clear()
50 |     idle_app.guest_clients.clear()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `idle_app`
  --> backend/tests/test_idle_shutdown.py:48:60
   |
47 | @pytest.mark.asyncio
48 | async def test_idle_shutdown_cancelled_when_client_returns(idle_app):
   |                                                            ^^^^^^^^
49 |     idle_app.operator_clients.clear()
50 |     idle_app.guest_clients.clear()
   |

ANN201 Missing return type annotation for public function `test_idle_shutdown_waits_for_active_jobs`
  --> backend/tests/test_idle_shutdown.py:61:11
   |
60 | @pytest.mark.asyncio
61 | async def test_idle_shutdown_waits_for_active_jobs(idle_app):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
62 |     idle_app.operator_clients.clear()
63 |     idle_app.guest_clients.clear()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `idle_app`
  --> backend/tests/test_idle_shutdown.py:61:52
   |
60 | @pytest.mark.asyncio
61 | async def test_idle_shutdown_waits_for_active_jobs(idle_app):
   |                                                    ^^^^^^^^
62 |     idle_app.operator_clients.clear()
63 |     idle_app.guest_clients.clear()
   |

I001 [*] Import block is un-sorted or un-formatted
 --> backend/tests/test_parse_peek_report.py:1:1
  |
1 | / import sys
2 | | from pathlib import Path
  | |________________________^
  |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> backend/tests/test_parse_peek_report.py:8:1
   |
 8 | / from backend.parse_peek_report import (
 9 | |     _parse_chakra_tokens,
10 | |     _parse_organ_tokens,
11 | |     _parse_special_metric,
12 | |     _tokenize_line,
13 | |     CHAKRA_ID_BY_NUM,
14 | | )
   | |_^
   |
help: Organize imports

ANN201 Missing return type annotation for public function `test_tokenize_line_handles_arrows_and_chevrons`
  --> backend/tests/test_parse_peek_report.py:17:5
   |
17 | def test_tokenize_line_handles_arrows_and_chevrons():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
18 |     line = "Organs -> LI -> Large Intestine > 53"
19 |     assert _tokenize_line(line) == ["Organs", "LI", "Large Intestine", "53"]
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_tokenize_line_handles_table_delimiters`
  --> backend/tests/test_parse_peek_report.py:22:5
   |
22 | def test_tokenize_line_handles_table_delimiters():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
23 |     line = "Organs | KI | Kidneys | 48"
24 |     assert _tokenize_line(line) == ["Organs", "KI", "Kidneys", "48"]
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_parse_organ_tokens_returns_mapped_id_and_value`
  --> backend/tests/test_parse_peek_report.py:27:5
   |
27 | def test_parse_organ_tokens_returns_mapped_id_and_value():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
28 |     tokens = ["Organs", "LI", "Large Intestine", "53"]
29 |     assert _parse_organ_tokens(tokens) == ("large_intestine", 53)
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_parse_organ_tokens_falls_back_to_single_token`
  --> backend/tests/test_parse_peek_report.py:32:5
   |
32 | def test_parse_organ_tokens_falls_back_to_single_token():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 |     tokens = ["Organs", "Pancreas", "41"]
34 |     assert _parse_organ_tokens(tokens) == ("pancreas_placeholder", 41)
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_parse_chakra_tokens_uses_numeric_mapping`
  --> backend/tests/test_parse_peek_report.py:37:5
   |
37 | def test_parse_chakra_tokens_uses_numeric_mapping():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |     tokens = ["Chakra", "6", "Indigo", "81"]
39 |     chakra_id, value = _parse_chakra_tokens(tokens)
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_parse_special_metric_extracts_inflammatory_score`
  --> backend/tests/test_parse_peek_report.py:44:5
   |
44 | def test_parse_special_metric_extracts_inflammatory_score():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
45 |     tokens = ["Organs", "As", "Inflammatory score", "7 (Very Low)"]
46 |     source_line = "Organs -> As -> Inflammatory score > 7 (Very Low)"
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_parse_special_metric_extracts_immunal_defense`
  --> backend/tests/test_parse_peek_report.py:53:5
   |
53 | def test_parse_special_metric_extracts_immunal_defense():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
54 |     tokens = ["Organs", "Ai", "Immunal defense", "72 (Normal)"]
55 |     source_line = "Organs -> Ai -> Immunal defense > 72 (Normal)"
   |
help: Add return type annotation: `None`

E402 Module level import not at top of file
  --> backend/tests/test_session_retention.py:16:1
   |
14 |     sys.path.append(str(BACKEND_ROOT))
15 |
16 | import session_fs  # pylint: disable=wrong-import-position
   | ^^^^^^^^^^^^^^^^^
17 | from paths import app_root
   |

E402 Module level import not at top of file
  --> backend/tests/test_session_retention.py:17:1
   |
16 | import session_fs  # pylint: disable=wrong-import-position
17 | from paths import app_root
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

ANN202 Missing return type annotation for private function `_reset_app_root`
  --> backend/tests/test_session_retention.py:21:5
   |
20 | @pytest.fixture(autouse=True)
21 | def _reset_app_root(monkeypatch, tmp_path):
   |     ^^^^^^^^^^^^^^^
22 |     monkeypatch.setenv("LONGQ_ROOT", str(tmp_path))
23 |     app_root.cache_clear()
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_session_retention.py:21:21
   |
20 | @pytest.fixture(autouse=True)
21 | def _reset_app_root(monkeypatch, tmp_path):
   |                     ^^^^^^^^^^^
22 |     monkeypatch.setenv("LONGQ_ROOT", str(tmp_path))
23 |     app_root.cache_clear()
   |

ANN001 Missing type annotation for function argument `tmp_path`
  --> backend/tests/test_session_retention.py:21:34
   |
20 | @pytest.fixture(autouse=True)
21 | def _reset_app_root(monkeypatch, tmp_path):
   |                                  ^^^^^^^^
22 |     monkeypatch.setenv("LONGQ_ROOT", str(tmp_path))
23 |     app_root.cache_clear()
   |

ANN201 Missing return type annotation for public function `test_purge_session_directories_respects_age_threshold`
  --> backend/tests/test_session_retention.py:36:5
   |
36 | def test_purge_session_directories_respects_age_threshold(monkeypatch):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
37 |     threshold = 2.0
38 |     older = _touch_session("old", age_hours=threshold + 1)
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_session_retention.py:36:59
   |
36 | def test_purge_session_directories_respects_age_threshold(monkeypatch):
   |                                                           ^^^^^^^^^^^
37 |     threshold = 2.0
38 |     older = _touch_session("old", age_hours=threshold + 1)
   |

ANN201 Missing return type annotation for public function `test_default_retention_hours_uses_env_override`
  --> backend/tests/test_session_retention.py:50:5
   |
50 | def test_default_retention_hours_uses_env_override(monkeypatch):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 |     baseline = session_fs.default_session_retention_hours()
52 |     monkeypatch.setenv("SESSION_FILE_RETENTION_HOURS", "12")
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_session_retention.py:50:52
   |
50 | def test_default_retention_hours_uses_env_override(monkeypatch):
   |                                                    ^^^^^^^^^^^
51 |     baseline = session_fs.default_session_retention_hours()
52 |     monkeypatch.setenv("SESSION_FILE_RETENTION_HOURS", "12")
   |

Found 173 errors.
[*] 16 fixable with the `--fix` option (23 hidden fixes can be enabled with the `--unsafe-fixes` option).
UP017 [*] Use `datetime.UTC` alias
   --> backend/app.py:120:68
    |
118 |             message = str(record.msg)
119 |         entry = {
120 |             "timestamp": datetime.fromtimestamp(record.created, tz=timezone.utc).isoformat(),
    |                                                                    ^^^^^^^^^^^^
121 |             "level": record.levelname,
122 |             "logger": record.name,
    |
help: Convert to `datetime.UTC` alias

UP017 [*] Use `datetime.UTC` alias
   --> backend/app.py:145:68
    |
143 |             message = str(record.msg)
144 |         payload = {
145 |             "timestamp": datetime.fromtimestamp(record.created, tz=timezone.utc).isoformat(),
    |                                                                    ^^^^^^^^^^^^
146 |             "level": record.levelname,
147 |             "logger": record.name,
    |
help: Convert to `datetime.UTC` alias

ANN201 Missing return type annotation for public function `lifespan`
   --> backend/app.py:265:11
    |
264 | @asynccontextmanager
265 | async def lifespan(_: FastAPI):
    |           ^^^^^^^^
266 |     global _event_loop
267 |     _event_loop = asyncio.get_running_loop()
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `_auth_middleware`
   --> backend/app.py:297:11
    |
296 | @app.middleware("http")
297 | async def _auth_middleware(request: Request, call_next):
    |           ^^^^^^^^^^^^^^^^
298 |     if request.url.path in _PUBLIC_HTTP_PATHS:
299 |         return await call_next(request)
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `call_next`
   --> backend/app.py:297:46
    |
296 | @app.middleware("http")
297 | async def _auth_middleware(request: Request, call_next):
    |                                              ^^^^^^^^^
298 |     if request.url.path in _PUBLIC_HTTP_PATHS:
299 |         return await call_next(request)
    |

ANN201 Missing return type annotation for public function `healthz`
   --> backend/app.py:307:11
    |
306 | @app.get("/healthz")
307 | async def healthz():
    |           ^^^^^^^
308 |     return {"status": "ok"}
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `metrics`
   --> backend/app.py:312:5
    |
311 | @app.get("/metrics")
312 | def metrics():
    |     ^^^^^^^
313 |     return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `diagnostics`
   --> backend/app.py:328:5
    |
327 | @app.get("/diagnostics")
328 | def diagnostics(limit: int = 20):
    |     ^^^^^^^^^^^
329 |     limit = max(1, min(limit, DIAGNOSTICS_MAX_ENTRIES))
330 |     return {"entries": _recent_diagnostics(limit)}
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `callback`
   --> backend/app.py:431:18
    |
431 | def _run_in_loop(callback, *args) -> None:
    |                  ^^^^^^^^
432 |     global _event_loop
433 |     try:
    |

ANN002 Missing type annotation for `*args`
   --> backend/app.py:431:28
    |
431 | def _run_in_loop(callback, *args) -> None:
    |                            ^^^^^
432 |     global _event_loop
433 |     try:
    |

ANN202 Missing return type annotation for private function `_cancel`
   --> backend/app.py:448:9
    |
447 | def _cancel_shutdown_timer(reason: str) -> None:
448 |     def _cancel():
    |         ^^^^^^^
449 |         global _shutdown_task
450 |         task = _shutdown_task
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `ws_guest`
   --> backend/app.py:568:11
    |
567 | @app.websocket("/ws/guest")
568 | async def ws_guest(ws: WebSocket):
    |           ^^^^^^^^
569 |     if not await ensure_websocket_authorized(ws):
570 |         return
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `ws_operator`
   --> backend/app.py:590:11
    |
589 | @app.websocket("/ws/operator")
590 | async def ws_operator(ws: WebSocket):
    |           ^^^^^^^^^^^
591 |     if not await ensure_websocket_authorized(ws):
592 |         return
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `broadcast`
   --> backend/app.py:611:11
    |
611 | async def broadcast(event: dict):
    |           ^^^^^^^^^
612 |     """Send JSON event to all connected guest screens."""
613 |     dead = []
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `operator_window_open`
   --> backend/app.py:629:11
    |
627 | # ----------------- Operator window lifecycle -----------------
628 | @app.post("/operator/window-open")
629 | async def operator_window_open():
    |           ^^^^^^^^^^^^^^^^^^^^
630 |     global operator_window_count
631 |     with _operator_window_lock:
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `operator_window_closed`
   --> backend/app.py:640:11
    |
639 | @app.post("/operator/window-closed")
640 | async def operator_window_closed():
    |           ^^^^^^^^^^^^^^^^^^^^^^
641 |     global operator_window_count
642 |     with _operator_window_lock:
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `create_session`
   --> backend/app.py:657:5
    |
655 | # ----------------- Sessions -----------------
656 | @app.post("/sessions", response_model=SessionOut)
657 | def create_session(payload: SessionCreate, db=Depends(get_session)):
    |     ^^^^^^^^^^^^^^
658 |     first = _canonicalize_name_part(payload.first_name)
659 |     last = _canonicalize_name_part(payload.last_name)
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:657:44
    |
655 | # ----------------- Sessions -----------------
656 | @app.post("/sessions", response_model=SessionOut)
657 | def create_session(payload: SessionCreate, db=Depends(get_session)):
    |                                            ^^
658 |     first = _canonicalize_name_part(payload.first_name)
659 |     last = _canonicalize_name_part(payload.last_name)
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:657:47
    |
655 | # ----------------- Sessions -----------------
656 | @app.post("/sessions", response_model=SessionOut)
657 | def create_session(payload: SessionCreate, db=Depends(get_session)):
    |                                               ^^^^^^^^^^^^^^^^^^^^
658 |     first = _canonicalize_name_part(payload.first_name)
659 |     last = _canonicalize_name_part(payload.last_name)
    |

ANN201 Missing return type annotation for public function `list_sessions`
   --> backend/app.py:693:5
    |
692 | @app.get("/sessions", response_model=list[SessionOut])
693 | def list_sessions(db=Depends(get_session)):
    |     ^^^^^^^^^^^^^
694 |     rows = db.exec(select(SessionRow).order_by(SessionRow.id.desc())).all()
695 |     return [
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:693:19
    |
692 | @app.get("/sessions", response_model=list[SessionOut])
693 | def list_sessions(db=Depends(get_session)):
    |                   ^^
694 |     rows = db.exec(select(SessionRow).order_by(SessionRow.id.desc())).all()
695 |     return [
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:693:22
    |
692 | @app.get("/sessions", response_model=list[SessionOut])
693 | def list_sessions(db=Depends(get_session)):
    |                      ^^^^^^^^^^^^^^^^^^^^
694 |     rows = db.exec(select(SessionRow).order_by(SessionRow.id.desc())).all()
695 |     return [
    |

ANN201 Missing return type annotation for public function `get_session_status`
   --> backend/app.py:712:5
    |
711 | @app.get("/sessions/{session_id}", response_model=SessionOut)
712 | def get_session_status(session_id: int, db=Depends(get_session)):
    |     ^^^^^^^^^^^^^^^^^^
713 |     s = db.get(SessionRow, session_id)
714 |     if not s:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:712:41
    |
711 | @app.get("/sessions/{session_id}", response_model=SessionOut)
712 | def get_session_status(session_id: int, db=Depends(get_session)):
    |                                         ^^
713 |     s = db.get(SessionRow, session_id)
714 |     if not s:
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:712:44
    |
711 | @app.get("/sessions/{session_id}", response_model=SessionOut)
712 | def get_session_status(session_id: int, db=Depends(get_session)):
    |                                            ^^^^^^^^^^^^^^^^^^^^
713 |     s = db.get(SessionRow, session_id)
714 |     if not s:
    |

ANN201 Missing return type annotation for public function `update_session`
   --> backend/app.py:730:5
    |
729 | @app.patch("/sessions/{session_id}", response_model=SessionOut)
730 | def update_session(session_id: int, payload: SessionUpdate, db=Depends(get_session)):
    |     ^^^^^^^^^^^^^^
731 |     s = db.get(SessionRow, session_id)
732 |     if not s:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:730:61
    |
729 | @app.patch("/sessions/{session_id}", response_model=SessionOut)
730 | def update_session(session_id: int, payload: SessionUpdate, db=Depends(get_session)):
    |                                                             ^^
731 |     s = db.get(SessionRow, session_id)
732 |     if not s:
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:730:64
    |
729 | @app.patch("/sessions/{session_id}", response_model=SessionOut)
730 | def update_session(session_id: int, payload: SessionUpdate, db=Depends(get_session)):
    |                                                                ^^^^^^^^^^^^^^^^^^^^
731 |     s = db.get(SessionRow, session_id)
732 |     if not s:
    |

ANN201 Missing return type annotation for public function `banner`
   --> backend/app.py:789:5
    |
787 | # Greet immediately
788 | @app.get("/sessions/{session_id}/banner", response_model=BannerOut)
789 | def banner(session_id: int, db=Depends(get_session)):
    |     ^^^^^^
790 |     s = db.get(SessionRow, session_id)
791 |     if not s:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:789:29
    |
787 | # Greet immediately
788 | @app.get("/sessions/{session_id}/banner", response_model=BannerOut)
789 | def banner(session_id: int, db=Depends(get_session)):
    |                             ^^
790 |     s = db.get(SessionRow, session_id)
791 |     if not s:
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:789:32
    |
787 | # Greet immediately
788 | @app.get("/sessions/{session_id}/banner", response_model=BannerOut)
789 | def banner(session_id: int, db=Depends(get_session)):
    |                                ^^^^^^^^^^^^^^^^^^^^
790 |     s = db.get(SessionRow, session_id)
791 |     if not s:
    |

ANN201 Missing return type annotation for public function `upload_report`
   --> backend/app.py:799:5
    |
797 | # ----------------- Upload / Parse / Publish -----------------
798 | @app.post("/sessions/{session_id}/upload/{kind}", response_model=FileOut)
799 | def upload_report(
    |     ^^^^^^^^^^^^^
800 |     session_id: int,
801 |     kind: str,
    |
help: Add return type annotation

B008 Do not perform function call `File` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:802:24
    |
800 |     session_id: int,
801 |     kind: str,
802 |     file: UploadFile = File(...),
    |                        ^^^^^^^^^
803 |     db=Depends(get_session),
804 | ):
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:803:5
    |
801 |     kind: str,
802 |     file: UploadFile = File(...),
803 |     db=Depends(get_session),
    |     ^^
804 | ):
805 |     s = db.get(SessionRow, session_id)
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:803:8
    |
801 |     kind: str,
802 |     file: UploadFile = File(...),
803 |     db=Depends(get_session),
    |        ^^^^^^^^^^^^^^^^^^^^
804 | ):
805 |     s = db.get(SessionRow, session_id)
    |

ANN201 Missing return type annotation for public function `parse_uploaded`
   --> backend/app.py:882:5
    |
881 | @app.post("/files/{file_id}/parse", response_model=ParsedOut)
882 | def parse_uploaded(file_id: int, db=Depends(get_session)):
    |     ^^^^^^^^^^^^^^
883 |     fr = db.get(FileRow, file_id)
884 |     if not fr:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:882:34
    |
881 | @app.post("/files/{file_id}/parse", response_model=ParsedOut)
882 | def parse_uploaded(file_id: int, db=Depends(get_session)):
    |                                  ^^
883 |     fr = db.get(FileRow, file_id)
884 |     if not fr:
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:882:37
    |
881 | @app.post("/files/{file_id}/parse", response_model=ParsedOut)
882 | def parse_uploaded(file_id: int, db=Depends(get_session)):
    |                                     ^^^^^^^^^^^^^^^^^^^^
883 |     fr = db.get(FileRow, file_id)
884 |     if not fr:
    |

ANN201 Missing return type annotation for public function `publish`
   --> backend/app.py:971:11
    |
970 | @app.post("/sessions/{session_id}/publish")
971 | async def publish(session_id: int, req: PublishRequest, db=Depends(get_session)):
    |           ^^^^^^^
972 |     s = db.get(SessionRow, session_id)
973 |     if not s:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:971:57
    |
970 | @app.post("/sessions/{session_id}/publish")
971 | async def publish(session_id: int, req: PublishRequest, db=Depends(get_session)):
    |                                                         ^^
972 |     s = db.get(SessionRow, session_id)
973 |     if not s:
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> backend/app.py:971:60
    |
970 | @app.post("/sessions/{session_id}/publish")
971 | async def publish(session_id: int, req: PublishRequest, db=Depends(get_session)):
    |                                                            ^^^^^^^^^^^^^^^^^^^^
972 |     s = db.get(SessionRow, session_id)
973 |     if not s:
    |

ANN201 Missing return type annotation for public function `get_parsed`
    --> backend/app.py:1007:5
     |
1005 | # Strict publish gate
1006 | @app.get("/sessions/{session_id}/parsed/{kind}", response_model=ParsedOut)
1007 | def get_parsed(session_id: int, kind: str, db=Depends(get_session)):
     |     ^^^^^^^^^^
1008 |     s = db.get(SessionRow, session_id)
1009 |     if not s:
     |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1007:44
     |
1005 | # Strict publish gate
1006 | @app.get("/sessions/{session_id}/parsed/{kind}", response_model=ParsedOut)
1007 | def get_parsed(session_id: int, kind: str, db=Depends(get_session)):
     |                                            ^^
1008 |     s = db.get(SessionRow, session_id)
1009 |     if not s:
     |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    --> backend/app.py:1007:47
     |
1005 | # Strict publish gate
1006 | @app.get("/sessions/{session_id}/parsed/{kind}", response_model=ParsedOut)
1007 | def get_parsed(session_id: int, kind: str, db=Depends(get_session)):
     |                                               ^^^^^^^^^^^^^^^^^^^^
1008 |     s = db.get(SessionRow, session_id)
1009 |     if not s:
     |

ANN201 Missing return type annotation for public function `get_parsed_bundle`
    --> backend/app.py:1022:5
     |
1021 | @app.get("/sessions/{session_id}/parsed", response_model=ParsedBundleOut)
1022 | def get_parsed_bundle(session_id: int, db=Depends(get_session)):
     |     ^^^^^^^^^^^^^^^^^
1023 |     s = db.get(SessionRow, session_id)
1024 |     if not s:
     |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1022:40
     |
1021 | @app.get("/sessions/{session_id}/parsed", response_model=ParsedBundleOut)
1022 | def get_parsed_bundle(session_id: int, db=Depends(get_session)):
     |                                        ^^
1023 |     s = db.get(SessionRow, session_id)
1024 |     if not s:
     |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    --> backend/app.py:1022:43
     |
1021 | @app.get("/sessions/{session_id}/parsed", response_model=ParsedBundleOut)
1022 | def get_parsed_bundle(session_id: int, db=Depends(get_session)):
     |                                           ^^^^^^^^^^^^^^^^^^^^
1023 |     s = db.get(SessionRow, session_id)
1024 |     if not s:
     |

ANN201 Missing return type annotation for public function `display_current`
    --> backend/app.py:1036:5
     |
1034 | # ----------------- Guest display binding -----------------
1035 | @app.get("/display/current", response_model=DisplayOut)
1036 | def display_current(db=Depends(get_session)):
     |     ^^^^^^^^^^^^^^^
1037 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1038 |     if not d or not d.current_session_id:
     |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1036:21
     |
1034 | # ----------------- Guest display binding -----------------
1035 | @app.get("/display/current", response_model=DisplayOut)
1036 | def display_current(db=Depends(get_session)):
     |                     ^^
1037 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1038 |     if not d or not d.current_session_id:
     |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    --> backend/app.py:1036:24
     |
1034 | # ----------------- Guest display binding -----------------
1035 | @app.get("/display/current", response_model=DisplayOut)
1036 | def display_current(db=Depends(get_session)):
     |                        ^^^^^^^^^^^^^^^^^^^^
1037 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1038 |     if not d or not d.current_session_id:
     |

ANN201 Missing return type annotation for public function `display_set`
    --> backend/app.py:1073:11
     |
1072 | @app.post("/display/current")
1073 | async def display_set(req: DisplaySet, db=Depends(get_session)):
     |           ^^^^^^^^^^^
1074 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1075 |     if not d:
     |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1073:40
     |
1072 | @app.post("/display/current")
1073 | async def display_set(req: DisplaySet, db=Depends(get_session)):
     |                                        ^^
1074 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1075 |     if not d:
     |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    --> backend/app.py:1073:43
     |
1072 | @app.post("/display/current")
1073 | async def display_set(req: DisplaySet, db=Depends(get_session)):
     |                                           ^^^^^^^^^^^^^^^^^^^^
1074 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1075 |     if not d:
     |

ANN201 Missing return type annotation for public function `close_session`
    --> backend/app.py:1106:5
     |
1105 | @app.post("/sessions/{session_id}/close")
1106 | def close_session(session_id: int, db=Depends(get_session)):
     |     ^^^^^^^^^^^^^
1107 |     s = db.get(SessionRow, session_id)
1108 |     if not s:
     |
help: Add return type annotation

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1106:36
     |
1105 | @app.post("/sessions/{session_id}/close")
1106 | def close_session(session_id: int, db=Depends(get_session)):
     |                                    ^^
1107 |     s = db.get(SessionRow, session_id)
1108 |     if not s:
     |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    --> backend/app.py:1106:39
     |
1105 | @app.post("/sessions/{session_id}/close")
1106 | def close_session(session_id: int, db=Depends(get_session)):
     |                                       ^^^^^^^^^^^^^^^^^^^^
1107 |     s = db.get(SessionRow, session_id)
1108 |     if not s:
     |

I001 [*] Import block is un-sorted or un-formatted
 --> backend/db.py:1:1
  |
1 | / import os
2 | | from sqlmodel import SQLModel, create_engine, Session
3 | | from sqlalchemy.pool import StaticPool
4 | |
5 | | from paths import backend_dir
  | |_____________________________^
6 |
7 |   DB_URL = os.getenv("DB_URL")
  |
help: Organize imports

ANN201 Missing return type annotation for public function `init_db`
  --> backend/db.py:23:5
   |
23 | def init_db():
   |     ^^^^^^^
24 |     if DB_URL:
25 |         SQLModel.metadata.create_all(engine)
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `get_session`
  --> backend/db.py:31:5
   |
31 | def get_session():
   |     ^^^^^^^^^^^
32 |     with Session(engine) as session:
33 |         yield session
   |
help: Add return type annotation

I001 [*] Import block is un-sorted or un-formatted
  --> backend/maintenance.py:11:1
   |
 9 |   """
10 |
11 | / from __future__ import annotations
12 | |
13 | | import argparse
14 | | import json
15 | | import os
16 | | import sys
17 | | import time
18 | | from dataclasses import dataclass
19 | | from pathlib import Path
20 | | from collections.abc import Iterable
21 | |
22 | | from paths import ensure_app_dirs, runtime_dir
23 | | from session_fs import (
24 | |     SESSION_LOCK_NAME,
25 | |     default_session_retention_hours,
26 | |     iter_session_dirs,
27 | |     purge_session_directories,
28 | |     reset_tmp_directory,
29 | |     remove_session_lock,
30 | | )
   | |_^
31 |
32 |   BACKEND_PID_NAME = "backend.pid"
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
 --> backend/models.py:2:1
  |
1 |   # models.py
2 | / from __future__ import annotations
3 | |
4 | | from typing import Any
5 | | from datetime import datetime
6 | | from enum import Enum
7 | | from sqlmodel import SQLModel, Field
8 | | from sqlalchemy import Column, JSON, String  # <-- use Column + JSON
  | |___________________________________________^
  |
help: Organize imports

E402 Module level import not at top of file
  --> backend/models.py:63:1
   |
62 | # --- Fixed guest-screen binding model ---
63 | from sqlmodel import Field as _Field
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

E401 [*] Multiple imports on one line
 --> backend/parse_food_pdf.py:3:1
  |
1 | #!/usr/bin/env python3
2 | # (See docstring in previous attempt for details.)
3 | import argparse, json, math, re, statistics
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
4 | from typing import Any
5 | import fitz  # PyMuPDF
  |
help: Split imports

I001 [*] Import block is un-sorted or un-formatted
 --> backend/parse_food_pdf.py:3:1
  |
1 |   #!/usr/bin/env python3
2 |   # (See docstring in previous attempt for details.)
3 | / import argparse, json, math, re, statistics
4 | | from typing import Any
5 | | import fitz  # PyMuPDF
  | |___________^
6 |
7 |   CATEGORY_NAMES = [
  |
help: Organize imports

ANN201 Missing return type annotation for public function `page_spans`
  --> backend/parse_food_pdf.py:64:5
   |
64 | def page_spans(page: fitz.Page):
   |     ^^^^^^^^^^
65 |     d = page.get_text("dict")
66 |     out = []
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `cluster_lines`
  --> backend/parse_food_pdf.py:81:5
   |
81 | def cluster_lines(spans, y_tol=Y_LINE_TOL):
   |     ^^^^^^^^^^^^^
82 |     lines = []
83 |     for sp in spans:
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `spans`
  --> backend/parse_food_pdf.py:81:19
   |
81 | def cluster_lines(spans, y_tol=Y_LINE_TOL):
   |                   ^^^^^
82 |     lines = []
83 |     for sp in spans:
   |

ANN001 Missing type annotation for function argument `y_tol`
  --> backend/parse_food_pdf.py:81:26
   |
81 | def cluster_lines(spans, y_tol=Y_LINE_TOL):
   |                          ^^^^^
82 |     lines = []
83 |     for sp in spans:
   |

ANN201 Missing return type annotation for public function `find_total_lines`
   --> backend/parse_food_pdf.py:99:5
    |
 99 | def find_total_lines(lines):
    |     ^^^^^^^^^^^^^^^^
100 |     totals = []
101 |     for ln in lines:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:99:22
    |
 99 | def find_total_lines(lines):
    |                      ^^^^^
100 |     totals = []
101 |     for ln in lines:
    |

ANN201 Missing return type annotation for public function `detect_headers`
   --> backend/parse_food_pdf.py:112:5
    |
112 | def detect_headers(lines):
    |     ^^^^^^^^^^^^^^
113 |     allowed = set(CATEGORY_NAMES)
114 |     headers = []
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:112:20
    |
112 | def detect_headers(lines):
    |                    ^^^^^
113 |     allowed = set(CATEGORY_NAMES)
114 |     headers = []
    |

ANN201 Missing return type annotation for public function `group_headers_into_rows`
   --> backend/parse_food_pdf.py:124:5
    |
124 | def group_headers_into_rows(headers):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
125 |     rows = []
126 |     for h in headers:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `headers`
   --> backend/parse_food_pdf.py:124:29
    |
124 | def group_headers_into_rows(headers):
    |                             ^^^^^^^
125 |     rows = []
126 |     for h in headers:
    |

ANN201 Missing return type annotation for public function `build_row_boxes`
   --> backend/parse_food_pdf.py:142:5
    |
142 | def build_row_boxes(rows, page_w: float):
    |     ^^^^^^^^^^^^^^^
143 |     boxes = {}
144 |     for row in rows:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `rows`
   --> backend/parse_food_pdf.py:142:21
    |
142 | def build_row_boxes(rows, page_w: float):
    |                     ^^^^
143 |     boxes = {}
144 |     for row in rows:
    |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:166:24
    |
166 | def find_footer_page_y(lines, page_height: float) -> float:
    |                        ^^^^^
167 |     for ln in reversed(lines):
168 |         txt = " ".join(s["t"] for s in ln).strip().lower()
    |

ANN001 Missing type annotation for function argument `a0`
   --> backend/parse_food_pdf.py:177:17
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                 ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `a1`
   --> backend/parse_food_pdf.py:177:21
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                     ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `b0`
   --> backend/parse_food_pdf.py:177:25
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                         ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `b1`
   --> backend/parse_food_pdf.py:177:29
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                             ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN201 Missing return type annotation for public function `clamp_y1_with_totals`
   --> backend/parse_food_pdf.py:181:5
    |
181 | def clamp_y1_with_totals(cat_boxes, totals):
    |     ^^^^^^^^^^^^^^^^^^^^
182 |     new = {}
183 |     for name, (y0, _, x0, x1) in cat_boxes.items():
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `cat_boxes`
   --> backend/parse_food_pdf.py:181:26
    |
181 | def clamp_y1_with_totals(cat_boxes, totals):
    |                          ^^^^^^^^^
182 |     new = {}
183 |     for name, (y0, _, x0, x1) in cat_boxes.items():
    |

ANN001 Missing type annotation for function argument `totals`
   --> backend/parse_food_pdf.py:181:37
    |
181 | def clamp_y1_with_totals(cat_boxes, totals):
    |                                     ^^^^^^
182 |     new = {}
183 |     for name, (y0, _, x0, x1) in cat_boxes.items():
    |

ANN201 Missing return type annotation for public function `find_scores_in_box`
   --> backend/parse_food_pdf.py:195:5
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |     ^^^^^^^^^^^^^^^^^^
196 |     scores = []
197 |     for ln in lines:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:195:24
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                        ^^^^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x0`
   --> backend/parse_food_pdf.py:195:31
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                               ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x1`
   --> backend/parse_food_pdf.py:195:35
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                                   ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y0`
   --> backend/parse_food_pdf.py:195:39
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                                       ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y1`
   --> backend/parse_food_pdf.py:195:43
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                                           ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN201 Missing return type annotation for public function `cluster_score_rows`
   --> backend/parse_food_pdf.py:211:5
    |
211 | def cluster_score_rows(scores, tol=ROW_CLUSTER_TOL):
    |     ^^^^^^^^^^^^^^^^^^
212 |     rows = []
213 |     for sc in scores:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `scores`
   --> backend/parse_food_pdf.py:211:24
    |
211 | def cluster_score_rows(scores, tol=ROW_CLUSTER_TOL):
    |                        ^^^^^^
212 |     rows = []
213 |     for sc in scores:
    |

ANN001 Missing type annotation for function argument `tol`
   --> backend/parse_food_pdf.py:211:32
    |
211 | def cluster_score_rows(scores, tol=ROW_CLUSTER_TOL):
    |                                ^^^
212 |     rows = []
213 |     for sc in scores:
    |

ANN201 Missing return type annotation for public function `build_row_bands`
   --> backend/parse_food_pdf.py:229:5
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |     ^^^^^^^^^^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `row_centers`
   --> backend/parse_food_pdf.py:229:21
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |                     ^^^^^^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |

ANN001 Missing type annotation for function argument `cat_y0`
   --> backend/parse_food_pdf.py:229:34
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |                                  ^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |

ANN001 Missing type annotation for function argument `cat_y1`
   --> backend/parse_food_pdf.py:229:42
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |                                          ^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |

ANN201 Missing return type annotation for public function `smart_join`
   --> backend/parse_food_pdf.py:242:5
    |
242 | def smart_join(parts):
    |     ^^^^^^^^^^
243 |     if not parts:
244 |         return ""
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `parts`
   --> backend/parse_food_pdf.py:242:16
    |
242 | def smart_join(parts):
    |                ^^^^^
243 |     if not parts:
244 |         return ""
    |

ANN201 Missing return type annotation for public function `collect_label_window`
   --> backend/parse_food_pdf.py:262:5
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |     ^^^^^^^^^^^^^^^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:262:26
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                          ^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y_top`
   --> backend/parse_food_pdf.py:262:33
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                 ^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y_bot`
   --> backend/parse_food_pdf.py:262:40
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                        ^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x_left`
   --> backend/parse_food_pdf.py:262:47
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                               ^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x_right`
   --> backend/parse_food_pdf.py:262:55
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                                       ^^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `expected_set`
   --> backend/parse_food_pdf.py:262:64
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                                                ^^^^^^^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN201 Missing return type annotation for public function `quantiles`
   --> backend/parse_food_pdf.py:280:5
    |
280 | def quantiles(values, qs):
    |     ^^^^^^^^^
281 |     if not values:
282 |         return [0.0] * len(qs)
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `values`
   --> backend/parse_food_pdf.py:280:15
    |
280 | def quantiles(values, qs):
    |               ^^^^^^
281 |     if not values:
282 |         return [0.0] * len(qs)
    |

ANN001 Missing type annotation for function argument `qs`
   --> backend/parse_food_pdf.py:280:23
    |
280 | def quantiles(values, qs):
    |                       ^^
281 |     if not values:
282 |         return [0.0] * len(qs)
    |

ANN201 Missing return type annotation for public function `kmeans1d_median`
   --> backend/parse_food_pdf.py:291:5
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |     ^^^^^^^^^^^^^^^
292 |     if not xs:
293 |         return []
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `xs`
   --> backend/parse_food_pdf.py:291:21
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |                     ^^
292 |     if not xs:
293 |         return []
    |

ANN001 Missing type annotation for function argument `k`
   --> backend/parse_food_pdf.py:291:25
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |                         ^
292 |     if not xs:
293 |         return []
    |

ANN001 Missing type annotation for function argument `iters`
   --> backend/parse_food_pdf.py:291:30
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |                              ^^^^^
292 |     if not xs:
293 |         return []
    |

ANN201 Missing return type annotation for public function `header_has_items`
   --> backend/parse_food_pdf.py:314:5
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |     ^^^^^^^^^^^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |
help: Add return type annotation: `bool`

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:314:22
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                      ^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `header`
   --> backend/parse_food_pdf.py:314:29
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                             ^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `header_row`
   --> backend/parse_food_pdf.py:314:52
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                                                    ^^^^^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `all_headers`
   --> backend/parse_food_pdf.py:314:64
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                                                                ^^^^^^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN201 Missing return type annotation for public function `decide_order_mode`
   --> backend/parse_food_pdf.py:340:5
    |
340 | def decide_order_mode(items_xy, row_groups):
    |     ^^^^^^^^^^^^^^^^^
341 |     if not items_xy:
342 |         return "row"
    |
help: Add return type annotation: `str`

ANN001 Missing type annotation for function argument `items_xy`
   --> backend/parse_food_pdf.py:340:23
    |
340 | def decide_order_mode(items_xy, row_groups):
    |                       ^^^^^^^^
341 |     if not items_xy:
342 |         return "row"
    |

ANN001 Missing type annotation for function argument `row_groups`
   --> backend/parse_food_pdf.py:340:33
    |
340 | def decide_order_mode(items_xy, row_groups):
    |                                 ^^^^^^^^^^
341 |     if not items_xy:
342 |         return "row"
    |

ANN202 Missing return type annotation for private function `col_idx`
   --> backend/parse_food_pdf.py:346:9
    |
344 |     centers = kmeans1d_median(xs, k=4, iters=25)
345 |
346 |     def col_idx(x):
    |         ^^^^^^^
347 |         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `x`
   --> backend/parse_food_pdf.py:346:17
    |
344 |     centers = kmeans1d_median(xs, k=4, iters=25)
345 |
346 |     def col_idx(x):
    |                 ^
347 |         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |

RUF059 Unpacked variable `hy0` is never used
   --> backend/parse_food_pdf.py:425:17
    |
423 |                 cname = h["name"]
424 |                 y0, y1, x0, x1 = cat_boxes[cname]
425 |                 hy0, hy1 = header_y_map.get(cname, (None, None))
    |                 ^^^
426 |
427 |                 scores = find_scores_in_box(lines, x0, x1, y0, y1)
    |
help: Prefix it with an underscore or any other dummy variable pattern

B905 `zip()` without an explicit `strict=` parameter
   --> backend/parse_food_pdf.py:440:48
    |
439 |                 tmp = []
440 |                 for g, (band_top, band_bot) in zip(row_groups, bands):
    |                                                ^^^^^^^^^^^^^^^^^^^^^^
441 |                     g = sorted(g, key=lambda s: s["x"])
442 |                     xs = [sc["x"] for sc in g]
    |
help: Add explicit value for parameter `strict=`

ANN202 Missing return type annotation for private function `col_index`
   --> backend/parse_food_pdf.py:489:25
    |
487 |                     centers = kmeans1d_median(xs_all, k=4, iters=25)
488 |
489 |                     def col_index(x):
    |                         ^^^^^^^^^
490 |                         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `x`
   --> backend/parse_food_pdf.py:489:35
    |
487 |                     centers = kmeans1d_median(xs_all, k=4, iters=25)
488 |
489 |                     def col_index(x):
    |                                   ^
490 |                         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |

B023 Function definition does not bind loop variable `centers`
   --> backend/parse_food_pdf.py:490:46
    |
489 |                     def col_index(x):
490 |                         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |                                              ^^^^^^^
491 |
492 |                     uniq_rows = sorted({round(v, 2) for v in (it["_ry"] for it in tmp)})
    |

B023 Function definition does not bind loop variable `centers`
   --> backend/parse_food_pdf.py:490:79
    |
489 |                     def col_index(x):
490 |                         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |                                                                               ^^^^^^^
491 |
492 |                     uniq_rows = sorted({round(v, 2) for v in (it["_ry"] for it in tmp)})
    |

B023 Function definition does not bind loop variable `i`
   --> backend/parse_food_pdf.py:490:87
    |
489 |                     def col_index(x):
490 |                         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |                                                                                       ^
491 |
492 |                     uniq_rows = sorted({round(v, 2) for v in (it["_ry"] for it in tmp)})
    |

ANN202 Missing return type annotation for private function `row_index`
   --> backend/parse_food_pdf.py:494:25
    |
492 |                     uniq_rows = sorted({round(v, 2) for v in (it["_ry"] for it in tmp)})
493 |
494 |                     def row_index(ry):
    |                         ^^^^^^^^^
495 |                         return min(range(len(uniq_rows)), key=lambda i: abs(ry - uniq_rows[i]))
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `ry`
   --> backend/parse_food_pdf.py:494:35
    |
492 |                     uniq_rows = sorted({round(v, 2) for v in (it["_ry"] for it in tmp)})
493 |
494 |                     def row_index(ry):
    |                                   ^^
495 |                         return min(range(len(uniq_rows)), key=lambda i: abs(ry - uniq_rows[i]))
    |

B023 Function definition does not bind loop variable `uniq_rows`
   --> backend/parse_food_pdf.py:495:46
    |
494 |                     def row_index(ry):
495 |                         return min(range(len(uniq_rows)), key=lambda i: abs(ry - uniq_rows[i]))
    |                                              ^^^^^^^^^
496 |
497 |                     for it in tmp:
    |

B023 Function definition does not bind loop variable `uniq_rows`
   --> backend/parse_food_pdf.py:495:82
    |
494 |                     def row_index(ry):
495 |                         return min(range(len(uniq_rows)), key=lambda i: abs(ry - uniq_rows[i]))
    |                                                                                  ^^^^^^^^^
496 |
497 |                     for it in tmp:
    |

B023 Function definition does not bind loop variable `i`
   --> backend/parse_food_pdf.py:495:92
    |
494 |                     def row_index(ry):
495 |                         return min(range(len(uniq_rows)), key=lambda i: abs(ry - uniq_rows[i]))
    |                                                                                            ^
496 |
497 |                     for it in tmp:
    |

ANN201 Missing return type annotation for public function `main`
   --> backend/parse_food_pdf.py:525:5
    |
525 | def main():
    |     ^^^^
526 |     ap = argparse.ArgumentParser(description="Parse PDF → JSON (v6g: per-category AUTO ordering).")
527 |     ap.add_argument("pdf")
    |
help: Add return type annotation: `None`

I001 [*] Import block is un-sorted or un-formatted
  --> backend/parse_hormones_pdf.py:4:1
   |
 2 |   """Parse Biostar hormones report PDFs into structured data."""
 3 |
 4 | / from __future__ import annotations
 5 | |
 6 | | import re
 7 | | import os
 8 | | from typing import Any
 9 | |
10 | | import fitz  # PyMuPDF
   | |___________^
   |
help: Organize imports

F401 [*] `os` imported but unused
 --> backend/parse_hormones_pdf.py:7:8
  |
6 | import re
7 | import os
  |        ^^
8 | from typing import Any
  |
help: Remove unused import: `os`

RUF001 String contains ambiguous `Β` (GREEK CAPITAL LETTER BETA). Did you mean `B` (LATIN CAPITAL LETTER B)?
  --> backend/parse_hormones_pdf.py:20:41
   |
18 |         return s
19 |     s = re.sub(r"[\u2010\u2011\u2012\u2013\u2014\u2212]", "-", s)
20 |     s = s.replace("β", "Beta").replace("Β", "Beta").replace("\u200b", "")
   |                                         ^
21 |     s = re.sub(r"\s+", " ", s)
22 |     return s.strip()
   |

B007 Loop control variable `idx` not used within loop body
  --> backend/parse_hormones_pdf.py:74:9
   |
72 | ) -> list[list[tuple[str, float]]]:
73 |     blocks: list[list[tuple[str, float]]] = []
74 |     for idx, page in enumerate(doc):
   |         ^^^
75 |         blk = _page_rate_block(page)
76 |         if not blk:
   |
help: Rename unused `idx` to `_idx`

I001 [*] Import block is un-sorted or un-formatted
  --> backend/parse_nutrition_pdf.py:4:1
   |
 2 |   """Parse nutrition report PDFs into structured data."""
 3 |
 4 | / from __future__ import annotations
 5 | |
 6 | | import os
 7 | | import re
 8 | | from collections.abc import Iterable
 9 | | from typing import Any
10 | |
11 | | import fitz  # PyMuPDF
   | |___________^
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> backend/parse_toxins_pdf.py:4:1
   |
 2 |   """Parse Biostar toxins report PDFs into structured data."""
 3 |
 4 | / from __future__ import annotations
 5 | |
 6 | | import os
 7 | | import re
 8 | | from typing import Any
 9 | |
10 | | import fitz  # PyMuPDF
   | |___________^
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
 --> backend/paths.py:1:1
  |
1 | / import os
2 | | from functools import lru_cache
3 | | from pathlib import Path
  | |________________________^
  |
help: Organize imports

E402 Module level import not at top of file
  --> backend/runner.py:12:1
   |
10 |         sys.path.insert(0, candidate)
11 |
12 | from uvicorn import Config, Server
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | try:  # prefer local import when executed from backend directory
   |

I001 [*] Import block is un-sorted or un-formatted
 --> backend/schemas.py:1:1
  |
1 | / from pydantic import BaseModel
2 | | from typing import Any, Literal
  | |_______________________________^
  |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> backend/session_fs.py:1:1
   |
 1 | / from __future__ import annotations
 2 | |
 3 | | import errno
 4 | | import os
 5 | | import shutil
 6 | | import time
 7 | | from dataclasses import dataclass
 8 | | from pathlib import Path
 9 | | from collections.abc import Iterable
10 | |
11 | | from paths import sessions_dir
   | |______________________________^
12 |
13 |   SESSION_LOCK_NAME = "session.lock"
   |
help: Organize imports

ANN001 Missing type annotation for function argument `fileobj`
 --> backend/storage.py:7:45
  |
7 | def save_upload(session_id: int, kind: str, fileobj) -> bytes:
  |                                             ^^^^^^^
8 |     """Store the uploaded PDF bytes in memory and return the raw payload."""
9 |     data = fileobj.read()
  |

ANN201 Missing return type annotation for public function `idle_app`
  --> backend/tests/test_idle_shutdown.py:15:11
   |
14 | @pytest_asyncio.fixture
15 | async def idle_app(monkeypatch):
   |           ^^^^^^^^
16 |     monkeypatch.setenv("EXIT_WHEN_IDLE", "true")
17 |     monkeypatch.setenv("EXIT_IDLE_DEBOUNCE_SEC", "0.05")
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_idle_shutdown.py:15:20
   |
14 | @pytest_asyncio.fixture
15 | async def idle_app(monkeypatch):
   |                    ^^^^^^^^^^^
16 |     monkeypatch.setenv("EXIT_WHEN_IDLE", "true")
17 |     monkeypatch.setenv("EXIT_IDLE_DEBOUNCE_SEC", "0.05")
   |

ANN201 Missing return type annotation for public function `test_idle_shutdown_triggers_after_debounce`
  --> backend/tests/test_idle_shutdown.py:37:11
   |
36 | @pytest.mark.asyncio
37 | async def test_idle_shutdown_triggers_after_debounce(idle_app):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |     idle_app.operator_clients.clear()
39 |     idle_app.guest_clients.clear()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `idle_app`
  --> backend/tests/test_idle_shutdown.py:37:54
   |
36 | @pytest.mark.asyncio
37 | async def test_idle_shutdown_triggers_after_debounce(idle_app):
   |                                                      ^^^^^^^^
38 |     idle_app.operator_clients.clear()
39 |     idle_app.guest_clients.clear()
   |

ANN201 Missing return type annotation for public function `test_idle_shutdown_cancelled_when_client_returns`
  --> backend/tests/test_idle_shutdown.py:48:11
   |
47 | @pytest.mark.asyncio
48 | async def test_idle_shutdown_cancelled_when_client_returns(idle_app):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
49 |     idle_app.operator_clients.clear()
50 |     idle_app.guest_clients.clear()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `idle_app`
  --> backend/tests/test_idle_shutdown.py:48:60
   |
47 | @pytest.mark.asyncio
48 | async def test_idle_shutdown_cancelled_when_client_returns(idle_app):
   |                                                            ^^^^^^^^
49 |     idle_app.operator_clients.clear()
50 |     idle_app.guest_clients.clear()
   |

ANN201 Missing return type annotation for public function `test_idle_shutdown_waits_for_active_jobs`
  --> backend/tests/test_idle_shutdown.py:61:11
   |
60 | @pytest.mark.asyncio
61 | async def test_idle_shutdown_waits_for_active_jobs(idle_app):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
62 |     idle_app.operator_clients.clear()
63 |     idle_app.guest_clients.clear()
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `idle_app`
  --> backend/tests/test_idle_shutdown.py:61:52
   |
60 | @pytest.mark.asyncio
61 | async def test_idle_shutdown_waits_for_active_jobs(idle_app):
   |                                                    ^^^^^^^^
62 |     idle_app.operator_clients.clear()
63 |     idle_app.guest_clients.clear()
   |

I001 [*] Import block is un-sorted or un-formatted
 --> backend/tests/test_parse_peek_report.py:1:1
  |
1 | / import sys
2 | | from pathlib import Path
  | |________________________^
  |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> backend/tests/test_parse_peek_report.py:8:1
   |
 8 | / from backend.parse_peek_report import (
 9 | |     _parse_chakra_tokens,
10 | |     _parse_organ_tokens,
11 | |     _parse_special_metric,
12 | |     _tokenize_line,
13 | |     CHAKRA_ID_BY_NUM,
14 | | )
   | |_^
   |
help: Organize imports

ANN201 Missing return type annotation for public function `test_tokenize_line_handles_arrows_and_chevrons`
  --> backend/tests/test_parse_peek_report.py:17:5
   |
17 | def test_tokenize_line_handles_arrows_and_chevrons():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
18 |     line = "Organs -> LI -> Large Intestine > 53"
19 |     assert _tokenize_line(line) == ["Organs", "LI", "Large Intestine", "53"]
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_tokenize_line_handles_table_delimiters`
  --> backend/tests/test_parse_peek_report.py:22:5
   |
22 | def test_tokenize_line_handles_table_delimiters():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
23 |     line = "Organs | KI | Kidneys | 48"
24 |     assert _tokenize_line(line) == ["Organs", "KI", "Kidneys", "48"]
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_parse_organ_tokens_returns_mapped_id_and_value`
  --> backend/tests/test_parse_peek_report.py:27:5
   |
27 | def test_parse_organ_tokens_returns_mapped_id_and_value():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
28 |     tokens = ["Organs", "LI", "Large Intestine", "53"]
29 |     assert _parse_organ_tokens(tokens) == ("large_intestine", 53)
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_parse_organ_tokens_falls_back_to_single_token`
  --> backend/tests/test_parse_peek_report.py:32:5
   |
32 | def test_parse_organ_tokens_falls_back_to_single_token():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 |     tokens = ["Organs", "Pancreas", "41"]
34 |     assert _parse_organ_tokens(tokens) == ("pancreas_placeholder", 41)
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_parse_chakra_tokens_uses_numeric_mapping`
  --> backend/tests/test_parse_peek_report.py:37:5
   |
37 | def test_parse_chakra_tokens_uses_numeric_mapping():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |     tokens = ["Chakra", "6", "Indigo", "81"]
39 |     chakra_id, value = _parse_chakra_tokens(tokens)
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_parse_special_metric_extracts_inflammatory_score`
  --> backend/tests/test_parse_peek_report.py:44:5
   |
44 | def test_parse_special_metric_extracts_inflammatory_score():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
45 |     tokens = ["Organs", "As", "Inflammatory score", "7 (Very Low)"]
46 |     source_line = "Organs -> As -> Inflammatory score > 7 (Very Low)"
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `test_parse_special_metric_extracts_immunal_defense`
  --> backend/tests/test_parse_peek_report.py:53:5
   |
53 | def test_parse_special_metric_extracts_immunal_defense():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
54 |     tokens = ["Organs", "Ai", "Immunal defense", "72 (Normal)"]
55 |     source_line = "Organs -> Ai -> Immunal defense > 72 (Normal)"
   |
help: Add return type annotation: `None`

E402 Module level import not at top of file
  --> backend/tests/test_session_retention.py:16:1
   |
14 |     sys.path.append(str(BACKEND_ROOT))
15 |
16 | import session_fs  # pylint: disable=wrong-import-position
   | ^^^^^^^^^^^^^^^^^
17 | from paths import app_root
   |

E402 Module level import not at top of file
  --> backend/tests/test_session_retention.py:17:1
   |
16 | import session_fs  # pylint: disable=wrong-import-position
17 | from paths import app_root
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

ANN202 Missing return type annotation for private function `_reset_app_root`
  --> backend/tests/test_session_retention.py:21:5
   |
20 | @pytest.fixture(autouse=True)
21 | def _reset_app_root(monkeypatch, tmp_path):
   |     ^^^^^^^^^^^^^^^
22 |     monkeypatch.setenv("LONGQ_ROOT", str(tmp_path))
23 |     app_root.cache_clear()
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_session_retention.py:21:21
   |
20 | @pytest.fixture(autouse=True)
21 | def _reset_app_root(monkeypatch, tmp_path):
   |                     ^^^^^^^^^^^
22 |     monkeypatch.setenv("LONGQ_ROOT", str(tmp_path))
23 |     app_root.cache_clear()
   |

ANN001 Missing type annotation for function argument `tmp_path`
  --> backend/tests/test_session_retention.py:21:34
   |
20 | @pytest.fixture(autouse=True)
21 | def _reset_app_root(monkeypatch, tmp_path):
   |                                  ^^^^^^^^
22 |     monkeypatch.setenv("LONGQ_ROOT", str(tmp_path))
23 |     app_root.cache_clear()
   |

ANN201 Missing return type annotation for public function `test_purge_session_directories_respects_age_threshold`
  --> backend/tests/test_session_retention.py:36:5
   |
36 | def test_purge_session_directories_respects_age_threshold(monkeypatch):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
37 |     threshold = 2.0
38 |     older = _touch_session("old", age_hours=threshold + 1)
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_session_retention.py:36:59
   |
36 | def test_purge_session_directories_respects_age_threshold(monkeypatch):
   |                                                           ^^^^^^^^^^^
37 |     threshold = 2.0
38 |     older = _touch_session("old", age_hours=threshold + 1)
   |

ANN201 Missing return type annotation for public function `test_default_retention_hours_uses_env_override`
  --> backend/tests/test_session_retention.py:50:5
   |
50 | def test_default_retention_hours_uses_env_override(monkeypatch):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 |     baseline = session_fs.default_session_retention_hours()
52 |     monkeypatch.setenv("SESSION_FILE_RETENTION_HOURS", "12")
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_session_retention.py:50:52
   |
50 | def test_default_retention_hours_uses_env_override(monkeypatch):
   |                                                    ^^^^^^^^^^^
51 |     baseline = session_fs.default_session_retention_hours()
52 |     monkeypatch.setenv("SESSION_FILE_RETENTION_HOURS", "12")
   |

Found 173 errors.
[*] 16 fixable with the `--fix` option (23 hidden fixes can be enabled with the `--unsafe-fixes` option).
ANN001 Missing type annotation for function argument `call_next`
   --> backend/app.py:297:46
    |
296 | @app.middleware("http")
297 | async def _auth_middleware(request: Request, call_next):
    |                                              ^^^^^^^^^
298 |     if request.url.path in _PUBLIC_HTTP_PATHS:
299 |         return await call_next(request)
    |

ANN001 Missing type annotation for function argument `callback`
   --> backend/app.py:431:18
    |
431 | def _run_in_loop(callback, *args) -> None:
    |                  ^^^^^^^^
432 |     global _event_loop
433 |     try:
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:657:44
    |
655 | # ----------------- Sessions -----------------
656 | @app.post("/sessions", response_model=SessionOut)
657 | def create_session(payload: SessionCreate, db=Depends(get_session)):
    |                                            ^^
658 |     first = _canonicalize_name_part(payload.first_name)
659 |     last = _canonicalize_name_part(payload.last_name)
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:693:19
    |
692 | @app.get("/sessions", response_model=list[SessionOut])
693 | def list_sessions(db=Depends(get_session)):
    |                   ^^
694 |     rows = db.exec(select(SessionRow).order_by(SessionRow.id.desc())).all()
695 |     return [
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:712:41
    |
711 | @app.get("/sessions/{session_id}", response_model=SessionOut)
712 | def get_session_status(session_id: int, db=Depends(get_session)):
    |                                         ^^
713 |     s = db.get(SessionRow, session_id)
714 |     if not s:
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:730:61
    |
729 | @app.patch("/sessions/{session_id}", response_model=SessionOut)
730 | def update_session(session_id: int, payload: SessionUpdate, db=Depends(get_session)):
    |                                                             ^^
731 |     s = db.get(SessionRow, session_id)
732 |     if not s:
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:789:29
    |
787 | # Greet immediately
788 | @app.get("/sessions/{session_id}/banner", response_model=BannerOut)
789 | def banner(session_id: int, db=Depends(get_session)):
    |                             ^^
790 |     s = db.get(SessionRow, session_id)
791 |     if not s:
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:803:5
    |
801 |     kind: str,
802 |     file: UploadFile = File(...),
803 |     db=Depends(get_session),
    |     ^^
804 | ):
805 |     s = db.get(SessionRow, session_id)
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:882:34
    |
881 | @app.post("/files/{file_id}/parse", response_model=ParsedOut)
882 | def parse_uploaded(file_id: int, db=Depends(get_session)):
    |                                  ^^
883 |     fr = db.get(FileRow, file_id)
884 |     if not fr:
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:971:57
    |
970 | @app.post("/sessions/{session_id}/publish")
971 | async def publish(session_id: int, req: PublishRequest, db=Depends(get_session)):
    |                                                         ^^
972 |     s = db.get(SessionRow, session_id)
973 |     if not s:
    |

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1007:44
     |
1005 | # Strict publish gate
1006 | @app.get("/sessions/{session_id}/parsed/{kind}", response_model=ParsedOut)
1007 | def get_parsed(session_id: int, kind: str, db=Depends(get_session)):
     |                                            ^^
1008 |     s = db.get(SessionRow, session_id)
1009 |     if not s:
     |

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1022:40
     |
1021 | @app.get("/sessions/{session_id}/parsed", response_model=ParsedBundleOut)
1022 | def get_parsed_bundle(session_id: int, db=Depends(get_session)):
     |                                        ^^
1023 |     s = db.get(SessionRow, session_id)
1024 |     if not s:
     |

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1036:21
     |
1034 | # ----------------- Guest display binding -----------------
1035 | @app.get("/display/current", response_model=DisplayOut)
1036 | def display_current(db=Depends(get_session)):
     |                     ^^
1037 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1038 |     if not d or not d.current_session_id:
     |

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1073:40
     |
1072 | @app.post("/display/current")
1073 | async def display_set(req: DisplaySet, db=Depends(get_session)):
     |                                        ^^
1074 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1075 |     if not d:
     |

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1106:36
     |
1105 | @app.post("/sessions/{session_id}/close")
1106 | def close_session(session_id: int, db=Depends(get_session)):
     |                                    ^^
1107 |     s = db.get(SessionRow, session_id)
1108 |     if not s:
     |

ANN001 Missing type annotation for function argument `spans`
  --> backend/parse_food_pdf.py:81:19
   |
81 | def cluster_lines(spans, y_tol=Y_LINE_TOL):
   |                   ^^^^^
82 |     lines = []
83 |     for sp in spans:
   |

ANN001 Missing type annotation for function argument `y_tol`
  --> backend/parse_food_pdf.py:81:26
   |
81 | def cluster_lines(spans, y_tol=Y_LINE_TOL):
   |                          ^^^^^
82 |     lines = []
83 |     for sp in spans:
   |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:99:22
    |
 99 | def find_total_lines(lines):
    |                      ^^^^^
100 |     totals = []
101 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:112:20
    |
112 | def detect_headers(lines):
    |                    ^^^^^
113 |     allowed = set(CATEGORY_NAMES)
114 |     headers = []
    |

ANN001 Missing type annotation for function argument `headers`
   --> backend/parse_food_pdf.py:124:29
    |
124 | def group_headers_into_rows(headers):
    |                             ^^^^^^^
125 |     rows = []
126 |     for h in headers:
    |

ANN001 Missing type annotation for function argument `rows`
   --> backend/parse_food_pdf.py:142:21
    |
142 | def build_row_boxes(rows, page_w: float):
    |                     ^^^^
143 |     boxes = {}
144 |     for row in rows:
    |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:166:24
    |
166 | def find_footer_page_y(lines, page_height: float) -> float:
    |                        ^^^^^
167 |     for ln in reversed(lines):
168 |         txt = " ".join(s["t"] for s in ln).strip().lower()
    |

ANN001 Missing type annotation for function argument `a0`
   --> backend/parse_food_pdf.py:177:17
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                 ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `a1`
   --> backend/parse_food_pdf.py:177:21
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                     ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `b0`
   --> backend/parse_food_pdf.py:177:25
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                         ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `b1`
   --> backend/parse_food_pdf.py:177:29
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                             ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `cat_boxes`
   --> backend/parse_food_pdf.py:181:26
    |
181 | def clamp_y1_with_totals(cat_boxes, totals):
    |                          ^^^^^^^^^
182 |     new = {}
183 |     for name, (y0, _, x0, x1) in cat_boxes.items():
    |

ANN001 Missing type annotation for function argument `totals`
   --> backend/parse_food_pdf.py:181:37
    |
181 | def clamp_y1_with_totals(cat_boxes, totals):
    |                                     ^^^^^^
182 |     new = {}
183 |     for name, (y0, _, x0, x1) in cat_boxes.items():
    |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:195:24
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                        ^^^^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x0`
   --> backend/parse_food_pdf.py:195:31
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                               ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x1`
   --> backend/parse_food_pdf.py:195:35
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                                   ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y0`
   --> backend/parse_food_pdf.py:195:39
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                                       ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y1`
   --> backend/parse_food_pdf.py:195:43
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                                           ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `scores`
   --> backend/parse_food_pdf.py:211:24
    |
211 | def cluster_score_rows(scores, tol=ROW_CLUSTER_TOL):
    |                        ^^^^^^
212 |     rows = []
213 |     for sc in scores:
    |

ANN001 Missing type annotation for function argument `tol`
   --> backend/parse_food_pdf.py:211:32
    |
211 | def cluster_score_rows(scores, tol=ROW_CLUSTER_TOL):
    |                                ^^^
212 |     rows = []
213 |     for sc in scores:
    |

ANN001 Missing type annotation for function argument `row_centers`
   --> backend/parse_food_pdf.py:229:21
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |                     ^^^^^^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |

ANN001 Missing type annotation for function argument `cat_y0`
   --> backend/parse_food_pdf.py:229:34
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |                                  ^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |

ANN001 Missing type annotation for function argument `cat_y1`
   --> backend/parse_food_pdf.py:229:42
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |                                          ^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |

ANN001 Missing type annotation for function argument `parts`
   --> backend/parse_food_pdf.py:242:16
    |
242 | def smart_join(parts):
    |                ^^^^^
243 |     if not parts:
244 |         return ""
    |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:262:26
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                          ^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y_top`
   --> backend/parse_food_pdf.py:262:33
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                 ^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y_bot`
   --> backend/parse_food_pdf.py:262:40
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                        ^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x_left`
   --> backend/parse_food_pdf.py:262:47
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                               ^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x_right`
   --> backend/parse_food_pdf.py:262:55
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                                       ^^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `expected_set`
   --> backend/parse_food_pdf.py:262:64
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                                                ^^^^^^^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `values`
   --> backend/parse_food_pdf.py:280:15
    |
280 | def quantiles(values, qs):
    |               ^^^^^^
281 |     if not values:
282 |         return [0.0] * len(qs)
    |

ANN001 Missing type annotation for function argument `qs`
   --> backend/parse_food_pdf.py:280:23
    |
280 | def quantiles(values, qs):
    |                       ^^
281 |     if not values:
282 |         return [0.0] * len(qs)
    |

ANN001 Missing type annotation for function argument `xs`
   --> backend/parse_food_pdf.py:291:21
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |                     ^^
292 |     if not xs:
293 |         return []
    |

ANN001 Missing type annotation for function argument `k`
   --> backend/parse_food_pdf.py:291:25
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |                         ^
292 |     if not xs:
293 |         return []
    |

ANN001 Missing type annotation for function argument `iters`
   --> backend/parse_food_pdf.py:291:30
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |                              ^^^^^
292 |     if not xs:
293 |         return []
    |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:314:22
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                      ^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `header`
   --> backend/parse_food_pdf.py:314:29
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                             ^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `header_row`
   --> backend/parse_food_pdf.py:314:52
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                                                    ^^^^^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `all_headers`
   --> backend/parse_food_pdf.py:314:64
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                                                                ^^^^^^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `items_xy`
   --> backend/parse_food_pdf.py:340:23
    |
340 | def decide_order_mode(items_xy, row_groups):
    |                       ^^^^^^^^
341 |     if not items_xy:
342 |         return "row"
    |

ANN001 Missing type annotation for function argument `row_groups`
   --> backend/parse_food_pdf.py:340:33
    |
340 | def decide_order_mode(items_xy, row_groups):
    |                                 ^^^^^^^^^^
341 |     if not items_xy:
342 |         return "row"
    |

ANN001 Missing type annotation for function argument `x`
   --> backend/parse_food_pdf.py:346:17
    |
344 |     centers = kmeans1d_median(xs, k=4, iters=25)
345 |
346 |     def col_idx(x):
    |                 ^
347 |         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |

ANN001 Missing type annotation for function argument `x`
   --> backend/parse_food_pdf.py:489:35
    |
487 |                     centers = kmeans1d_median(xs_all, k=4, iters=25)
488 |
489 |                     def col_index(x):
    |                                   ^
490 |                         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |

ANN001 Missing type annotation for function argument `ry`
   --> backend/parse_food_pdf.py:494:35
    |
492 |                     uniq_rows = sorted({round(v, 2) for v in (it["_ry"] for it in tmp)})
493 |
494 |                     def row_index(ry):
    |                                   ^^
495 |                         return min(range(len(uniq_rows)), key=lambda i: abs(ry - uniq_rows[i]))
    |

ANN001 Missing type annotation for function argument `fileobj`
 --> backend/storage.py:7:45
  |
7 | def save_upload(session_id: int, kind: str, fileobj) -> bytes:
  |                                             ^^^^^^^
8 |     """Store the uploaded PDF bytes in memory and return the raw payload."""
9 |     data = fileobj.read()
  |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_idle_shutdown.py:15:20
   |
14 | @pytest_asyncio.fixture
15 | async def idle_app(monkeypatch):
   |                    ^^^^^^^^^^^
16 |     monkeypatch.setenv("EXIT_WHEN_IDLE", "true")
17 |     monkeypatch.setenv("EXIT_IDLE_DEBOUNCE_SEC", "0.05")
   |

ANN001 Missing type annotation for function argument `idle_app`
  --> backend/tests/test_idle_shutdown.py:37:54
   |
36 | @pytest.mark.asyncio
37 | async def test_idle_shutdown_triggers_after_debounce(idle_app):
   |                                                      ^^^^^^^^
38 |     idle_app.operator_clients.clear()
39 |     idle_app.guest_clients.clear()
   |

ANN001 Missing type annotation for function argument `idle_app`
  --> backend/tests/test_idle_shutdown.py:48:60
   |
47 | @pytest.mark.asyncio
48 | async def test_idle_shutdown_cancelled_when_client_returns(idle_app):
   |                                                            ^^^^^^^^
49 |     idle_app.operator_clients.clear()
50 |     idle_app.guest_clients.clear()
   |

ANN001 Missing type annotation for function argument `idle_app`
  --> backend/tests/test_idle_shutdown.py:61:52
   |
60 | @pytest.mark.asyncio
61 | async def test_idle_shutdown_waits_for_active_jobs(idle_app):
   |                                                    ^^^^^^^^
62 |     idle_app.operator_clients.clear()
63 |     idle_app.guest_clients.clear()
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_session_retention.py:21:21
   |
20 | @pytest.fixture(autouse=True)
21 | def _reset_app_root(monkeypatch, tmp_path):
   |                     ^^^^^^^^^^^
22 |     monkeypatch.setenv("LONGQ_ROOT", str(tmp_path))
23 |     app_root.cache_clear()
   |

ANN001 Missing type annotation for function argument `tmp_path`
  --> backend/tests/test_session_retention.py:21:34
   |
20 | @pytest.fixture(autouse=True)
21 | def _reset_app_root(monkeypatch, tmp_path):
   |                                  ^^^^^^^^
22 |     monkeypatch.setenv("LONGQ_ROOT", str(tmp_path))
23 |     app_root.cache_clear()
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_session_retention.py:36:59
   |
36 | def test_purge_session_directories_respects_age_threshold(monkeypatch):
   |                                                           ^^^^^^^^^^^
37 |     threshold = 2.0
38 |     older = _touch_session("old", age_hours=threshold + 1)
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_session_retention.py:50:52
   |
50 | def test_default_retention_hours_uses_env_override(monkeypatch):
   |                                                    ^^^^^^^^^^^
51 |     baseline = session_fs.default_session_retention_hours()
52 |     monkeypatch.setenv("SESSION_FILE_RETENTION_HOURS", "12")
   |

Found 68 errors.
ANN001 Missing type annotation for function argument `call_next`
   --> backend/app.py:297:46
    |
296 | @app.middleware("http")
297 | async def _auth_middleware(request: Request, call_next):
    |                                              ^^^^^^^^^
298 |     if request.url.path in _PUBLIC_HTTP_PATHS:
299 |         return await call_next(request)
    |

ANN001 Missing type annotation for function argument `callback`
   --> backend/app.py:431:18
    |
431 | def _run_in_loop(callback, *args) -> None:
    |                  ^^^^^^^^
432 |     global _event_loop
433 |     try:
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:657:44
    |
655 | # ----------------- Sessions -----------------
656 | @app.post("/sessions", response_model=SessionOut)
657 | def create_session(payload: SessionCreate, db=Depends(get_session)):
    |                                            ^^
658 |     first = _canonicalize_name_part(payload.first_name)
659 |     last = _canonicalize_name_part(payload.last_name)
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:693:19
    |
692 | @app.get("/sessions", response_model=list[SessionOut])
693 | def list_sessions(db=Depends(get_session)):
    |                   ^^
694 |     rows = db.exec(select(SessionRow).order_by(SessionRow.id.desc())).all()
695 |     return [
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:712:41
    |
711 | @app.get("/sessions/{session_id}", response_model=SessionOut)
712 | def get_session_status(session_id: int, db=Depends(get_session)):
    |                                         ^^
713 |     s = db.get(SessionRow, session_id)
714 |     if not s:
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:730:61
    |
729 | @app.patch("/sessions/{session_id}", response_model=SessionOut)
730 | def update_session(session_id: int, payload: SessionUpdate, db=Depends(get_session)):
    |                                                             ^^
731 |     s = db.get(SessionRow, session_id)
732 |     if not s:
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:789:29
    |
787 | # Greet immediately
788 | @app.get("/sessions/{session_id}/banner", response_model=BannerOut)
789 | def banner(session_id: int, db=Depends(get_session)):
    |                             ^^
790 |     s = db.get(SessionRow, session_id)
791 |     if not s:
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:803:5
    |
801 |     kind: str,
802 |     file: UploadFile = File(...),
803 |     db=Depends(get_session),
    |     ^^
804 | ):
805 |     s = db.get(SessionRow, session_id)
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:882:34
    |
881 | @app.post("/files/{file_id}/parse", response_model=ParsedOut)
882 | def parse_uploaded(file_id: int, db=Depends(get_session)):
    |                                  ^^
883 |     fr = db.get(FileRow, file_id)
884 |     if not fr:
    |

ANN001 Missing type annotation for function argument `db`
   --> backend/app.py:971:57
    |
970 | @app.post("/sessions/{session_id}/publish")
971 | async def publish(session_id: int, req: PublishRequest, db=Depends(get_session)):
    |                                                         ^^
972 |     s = db.get(SessionRow, session_id)
973 |     if not s:
    |

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1007:44
     |
1005 | # Strict publish gate
1006 | @app.get("/sessions/{session_id}/parsed/{kind}", response_model=ParsedOut)
1007 | def get_parsed(session_id: int, kind: str, db=Depends(get_session)):
     |                                            ^^
1008 |     s = db.get(SessionRow, session_id)
1009 |     if not s:
     |

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1022:40
     |
1021 | @app.get("/sessions/{session_id}/parsed", response_model=ParsedBundleOut)
1022 | def get_parsed_bundle(session_id: int, db=Depends(get_session)):
     |                                        ^^
1023 |     s = db.get(SessionRow, session_id)
1024 |     if not s:
     |

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1036:21
     |
1034 | # ----------------- Guest display binding -----------------
1035 | @app.get("/display/current", response_model=DisplayOut)
1036 | def display_current(db=Depends(get_session)):
     |                     ^^
1037 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1038 |     if not d or not d.current_session_id:
     |

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1073:40
     |
1072 | @app.post("/display/current")
1073 | async def display_set(req: DisplaySet, db=Depends(get_session)):
     |                                        ^^
1074 |     d = db.exec(select(DisplayRow).where(DisplayRow.code == "main")).first()
1075 |     if not d:
     |

ANN001 Missing type annotation for function argument `db`
    --> backend/app.py:1106:36
     |
1105 | @app.post("/sessions/{session_id}/close")
1106 | def close_session(session_id: int, db=Depends(get_session)):
     |                                    ^^
1107 |     s = db.get(SessionRow, session_id)
1108 |     if not s:
     |

ANN001 Missing type annotation for function argument `spans`
  --> backend/parse_food_pdf.py:81:19
   |
81 | def cluster_lines(spans, y_tol=Y_LINE_TOL):
   |                   ^^^^^
82 |     lines = []
83 |     for sp in spans:
   |

ANN001 Missing type annotation for function argument `y_tol`
  --> backend/parse_food_pdf.py:81:26
   |
81 | def cluster_lines(spans, y_tol=Y_LINE_TOL):
   |                          ^^^^^
82 |     lines = []
83 |     for sp in spans:
   |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:99:22
    |
 99 | def find_total_lines(lines):
    |                      ^^^^^
100 |     totals = []
101 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:112:20
    |
112 | def detect_headers(lines):
    |                    ^^^^^
113 |     allowed = set(CATEGORY_NAMES)
114 |     headers = []
    |

ANN001 Missing type annotation for function argument `headers`
   --> backend/parse_food_pdf.py:124:29
    |
124 | def group_headers_into_rows(headers):
    |                             ^^^^^^^
125 |     rows = []
126 |     for h in headers:
    |

ANN001 Missing type annotation for function argument `rows`
   --> backend/parse_food_pdf.py:142:21
    |
142 | def build_row_boxes(rows, page_w: float):
    |                     ^^^^
143 |     boxes = {}
144 |     for row in rows:
    |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:166:24
    |
166 | def find_footer_page_y(lines, page_height: float) -> float:
    |                        ^^^^^
167 |     for ln in reversed(lines):
168 |         txt = " ".join(s["t"] for s in ln).strip().lower()
    |

ANN001 Missing type annotation for function argument `a0`
   --> backend/parse_food_pdf.py:177:17
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                 ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `a1`
   --> backend/parse_food_pdf.py:177:21
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                     ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `b0`
   --> backend/parse_food_pdf.py:177:25
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                         ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `b1`
   --> backend/parse_food_pdf.py:177:29
    |
177 | def intersect_x(a0, a1, b0, b1) -> float:
    |                             ^^
178 |     return max(0.0, min(a1, b1) - max(a0, b0))
    |

ANN001 Missing type annotation for function argument `cat_boxes`
   --> backend/parse_food_pdf.py:181:26
    |
181 | def clamp_y1_with_totals(cat_boxes, totals):
    |                          ^^^^^^^^^
182 |     new = {}
183 |     for name, (y0, _, x0, x1) in cat_boxes.items():
    |

ANN001 Missing type annotation for function argument `totals`
   --> backend/parse_food_pdf.py:181:37
    |
181 | def clamp_y1_with_totals(cat_boxes, totals):
    |                                     ^^^^^^
182 |     new = {}
183 |     for name, (y0, _, x0, x1) in cat_boxes.items():
    |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:195:24
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                        ^^^^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x0`
   --> backend/parse_food_pdf.py:195:31
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                               ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x1`
   --> backend/parse_food_pdf.py:195:35
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                                   ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y0`
   --> backend/parse_food_pdf.py:195:39
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                                       ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y1`
   --> backend/parse_food_pdf.py:195:43
    |
195 | def find_scores_in_box(lines, x0, x1, y0, y1):
    |                                           ^^
196 |     scores = []
197 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `scores`
   --> backend/parse_food_pdf.py:211:24
    |
211 | def cluster_score_rows(scores, tol=ROW_CLUSTER_TOL):
    |                        ^^^^^^
212 |     rows = []
213 |     for sc in scores:
    |

ANN001 Missing type annotation for function argument `tol`
   --> backend/parse_food_pdf.py:211:32
    |
211 | def cluster_score_rows(scores, tol=ROW_CLUSTER_TOL):
    |                                ^^^
212 |     rows = []
213 |     for sc in scores:
    |

ANN001 Missing type annotation for function argument `row_centers`
   --> backend/parse_food_pdf.py:229:21
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |                     ^^^^^^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |

ANN001 Missing type annotation for function argument `cat_y0`
   --> backend/parse_food_pdf.py:229:34
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |                                  ^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |

ANN001 Missing type annotation for function argument `cat_y1`
   --> backend/parse_food_pdf.py:229:42
    |
229 | def build_row_bands(row_centers, cat_y0, cat_y1):
    |                                          ^^^^^^
230 |     bands = []
231 |     if not row_centers:
    |

ANN001 Missing type annotation for function argument `parts`
   --> backend/parse_food_pdf.py:242:16
    |
242 | def smart_join(parts):
    |                ^^^^^
243 |     if not parts:
244 |         return ""
    |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:262:26
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                          ^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y_top`
   --> backend/parse_food_pdf.py:262:33
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                 ^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `y_bot`
   --> backend/parse_food_pdf.py:262:40
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                        ^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x_left`
   --> backend/parse_food_pdf.py:262:47
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                               ^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `x_right`
   --> backend/parse_food_pdf.py:262:55
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                                       ^^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `expected_set`
   --> backend/parse_food_pdf.py:262:64
    |
262 | def collect_label_window(lines, y_top, y_bot, x_left, x_right, expected_set):
    |                                                                ^^^^^^^^^^^^
263 |     parts = []
264 |     for ln in lines:
    |

ANN001 Missing type annotation for function argument `values`
   --> backend/parse_food_pdf.py:280:15
    |
280 | def quantiles(values, qs):
    |               ^^^^^^
281 |     if not values:
282 |         return [0.0] * len(qs)
    |

ANN001 Missing type annotation for function argument `qs`
   --> backend/parse_food_pdf.py:280:23
    |
280 | def quantiles(values, qs):
    |                       ^^
281 |     if not values:
282 |         return [0.0] * len(qs)
    |

ANN001 Missing type annotation for function argument `xs`
   --> backend/parse_food_pdf.py:291:21
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |                     ^^
292 |     if not xs:
293 |         return []
    |

ANN001 Missing type annotation for function argument `k`
   --> backend/parse_food_pdf.py:291:25
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |                         ^
292 |     if not xs:
293 |         return []
    |

ANN001 Missing type annotation for function argument `iters`
   --> backend/parse_food_pdf.py:291:30
    |
291 | def kmeans1d_median(xs, k=4, iters=20):
    |                              ^^^^^
292 |     if not xs:
293 |         return []
    |

ANN001 Missing type annotation for function argument `lines`
   --> backend/parse_food_pdf.py:314:22
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                      ^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `header`
   --> backend/parse_food_pdf.py:314:29
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                             ^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `header_row`
   --> backend/parse_food_pdf.py:314:52
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                                                    ^^^^^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `all_headers`
   --> backend/parse_food_pdf.py:314:64
    |
314 | def header_has_items(lines, header, page_w: float, header_row, all_headers):
    |                                                                ^^^^^^^^^^^
315 |     row = sorted(header_row, key=lambda r: r["x0"])
316 |     if len(row) == 1:
    |

ANN001 Missing type annotation for function argument `items_xy`
   --> backend/parse_food_pdf.py:340:23
    |
340 | def decide_order_mode(items_xy, row_groups):
    |                       ^^^^^^^^
341 |     if not items_xy:
342 |         return "row"
    |

ANN001 Missing type annotation for function argument `row_groups`
   --> backend/parse_food_pdf.py:340:33
    |
340 | def decide_order_mode(items_xy, row_groups):
    |                                 ^^^^^^^^^^
341 |     if not items_xy:
342 |         return "row"
    |

ANN001 Missing type annotation for function argument `x`
   --> backend/parse_food_pdf.py:346:17
    |
344 |     centers = kmeans1d_median(xs, k=4, iters=25)
345 |
346 |     def col_idx(x):
    |                 ^
347 |         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |

ANN001 Missing type annotation for function argument `x`
   --> backend/parse_food_pdf.py:489:35
    |
487 |                     centers = kmeans1d_median(xs_all, k=4, iters=25)
488 |
489 |                     def col_index(x):
    |                                   ^
490 |                         return min(range(len(centers)), key=lambda i: abs(x - centers[i]))
    |

ANN001 Missing type annotation for function argument `ry`
   --> backend/parse_food_pdf.py:494:35
    |
492 |                     uniq_rows = sorted({round(v, 2) for v in (it["_ry"] for it in tmp)})
493 |
494 |                     def row_index(ry):
    |                                   ^^
495 |                         return min(range(len(uniq_rows)), key=lambda i: abs(ry - uniq_rows[i]))
    |

ANN001 Missing type annotation for function argument `fileobj`
 --> backend/storage.py:7:45
  |
7 | def save_upload(session_id: int, kind: str, fileobj) -> bytes:
  |                                             ^^^^^^^
8 |     """Store the uploaded PDF bytes in memory and return the raw payload."""
9 |     data = fileobj.read()
  |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_idle_shutdown.py:15:20
   |
14 | @pytest_asyncio.fixture
15 | async def idle_app(monkeypatch):
   |                    ^^^^^^^^^^^
16 |     monkeypatch.setenv("EXIT_WHEN_IDLE", "true")
17 |     monkeypatch.setenv("EXIT_IDLE_DEBOUNCE_SEC", "0.05")
   |

ANN001 Missing type annotation for function argument `idle_app`
  --> backend/tests/test_idle_shutdown.py:37:54
   |
36 | @pytest.mark.asyncio
37 | async def test_idle_shutdown_triggers_after_debounce(idle_app):
   |                                                      ^^^^^^^^
38 |     idle_app.operator_clients.clear()
39 |     idle_app.guest_clients.clear()
   |

ANN001 Missing type annotation for function argument `idle_app`
  --> backend/tests/test_idle_shutdown.py:48:60
   |
47 | @pytest.mark.asyncio
48 | async def test_idle_shutdown_cancelled_when_client_returns(idle_app):
   |                                                            ^^^^^^^^
49 |     idle_app.operator_clients.clear()
50 |     idle_app.guest_clients.clear()
   |

ANN001 Missing type annotation for function argument `idle_app`
  --> backend/tests/test_idle_shutdown.py:61:52
   |
60 | @pytest.mark.asyncio
61 | async def test_idle_shutdown_waits_for_active_jobs(idle_app):
   |                                                    ^^^^^^^^
62 |     idle_app.operator_clients.clear()
63 |     idle_app.guest_clients.clear()
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_session_retention.py:21:21
   |
20 | @pytest.fixture(autouse=True)
21 | def _reset_app_root(monkeypatch, tmp_path):
   |                     ^^^^^^^^^^^
22 |     monkeypatch.setenv("LONGQ_ROOT", str(tmp_path))
23 |     app_root.cache_clear()
   |

ANN001 Missing type annotation for function argument `tmp_path`
  --> backend/tests/test_session_retention.py:21:34
   |
20 | @pytest.fixture(autouse=True)
21 | def _reset_app_root(monkeypatch, tmp_path):
   |                                  ^^^^^^^^
22 |     monkeypatch.setenv("LONGQ_ROOT", str(tmp_path))
23 |     app_root.cache_clear()
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_session_retention.py:36:59
   |
36 | def test_purge_session_directories_respects_age_threshold(monkeypatch):
   |                                                           ^^^^^^^^^^^
37 |     threshold = 2.0
38 |     older = _touch_session("old", age_hours=threshold + 1)
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> backend/tests/test_session_retention.py:50:52
   |
50 | def test_default_retention_hours_uses_env_override(monkeypatch):
   |                                                    ^^^^^^^^^^^
51 |     baseline = session_fs.default_session_retention_hours()
52 |     monkeypatch.setenv("SESSION_FILE_RETENTION_HOURS", "12")
   |

Found 68 errors.
